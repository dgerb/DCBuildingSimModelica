/* DSblock model generated by Dymola from Modelica model DC_Tool.Converters.Examples.ConverterTesting
 Dymola Version 2016 FD01 (32-bit), 2015-10-13 translated this at Wed Nov 07 12:34:25 2018

   */

#include <matrixop.h>
/* Declaration of C-structs */
struct DymStruc0;
struct DymStruc0 {
  int  id_0member;
};
DYMOLA_STATIC struct DymStruc0 DymStruc0_construct(int   id_02) {
  struct DymStruc0 dummy_0;
  dummy_0.id_0member = id_02;
  return dummy_0;
}
/* Prototypes for functions used in model */
DYMOLA_STATIC double   Buildings_Utilities_Math_Functions_BaseClasses_derx_0spliceFunction
  (double  pos0_0, double  neg0_0, double  x0_0, double  deltax0_0, double  
  dpos0_0, double  dneg0_0, double  dx0_0, double  ddeltax0_0);
DYMOLA_STATIC double   Buildings_Utilities_Math_Functions_spliceFunction(double 
   pos0_0, double  neg0_0, double  x0_0, double  deltax0_0);
DYMOLA_STATIC double   Modelica_Blocks_Sources_CombiTimeTable_getDerTableValue_M
  (struct DymStruc0 tableID0_0, int  icol0_0, double  timeIn0_0, double  
  nextTimeEvent0_0, double  prex_0nextTimeEvent, double  tableAvailable0_0, 
  double  derx_0timeIn);
DYMOLA_STATIC double   Modelica_Blocks_Sources_CombiTimeTable_getNextTimeEvent_M
  (struct DymStruc0 tableID0_0, double  timeIn0_0, double  tableAvailable0_0);
DYMOLA_STATIC double   Modelica_Blocks_Sources_CombiTimeTable_getTableTimeTmax_M
  (struct DymStruc0 tableID0_0, double  tableAvailable0_0);
DYMOLA_STATIC double   Modelica_Blocks_Sources_CombiTimeTable_getTableTimeTmin_M
  (struct DymStruc0 tableID0_0, double  tableAvailable0_0);
DYMOLA_STATIC double   Modelica_Blocks_Sources_CombiTimeTable_getTableValue_M(
  struct DymStruc0 tableID0_0, int  icol0_0, double  timeIn0_0, double  
  nextTimeEvent0_0, double  prex_0nextTimeEvent, double  tableAvailable0_0);
DYMOLA_STATIC double   Modelica_Blocks_Sources_CombiTimeTable_readTableData_M(
  struct DymStruc0 tableID0_0, int  forceRead0_0, int  verboseRead0_0);
DYMOLA_STATIC double   Modelica_Blocks_Tables_CombiTable1D_getDerTableValue_M(
  struct DymStruc0 tableID0_0, int  icol0_0, double  u0_0, double  
  tableAvailable0_0, double  derx_0u);
DYMOLA_STATIC double   Modelica_Blocks_Tables_CombiTable1D_getTableValue_M(
  struct DymStruc0 tableID0_0, int  icol0_0, double  u0_0, double  
  tableAvailable0_0);
DYMOLA_STATIC struct DymStruc0  Modelica_Blocks_Types_ExternalCombiTable1D_M(
  const char*  tableName0_0, const char*  fileName0_0, RealArray   table0_0, 
  IntegerArray   columns0_0, int  smoothness0_0, int id_, int alwaysMakeNew_);
DYMOLA_STATIC void Modelica_Blocks_Types_ExternalCombiTable1D_destructor_M(
  void* externalCombiTable1D0_0);
DYMOLA_STATIC struct DymStruc0  Modelica_Blocks_Types_ExternalCombiTimeTable_M(
  const char*  tableName0_0, const char*  fileName0_0, RealArray   table0_0, 
  double  startTime0_0, IntegerArray   columns0_0, int  smoothness0_0, int  
  extrapolation0_0, int id_, int alwaysMakeNew_);
DYMOLA_STATIC void Modelica_Blocks_Types_ExternalCombiTimeTable_destructor_M(
  void* externalCombiTimeTable0_0);
/* Codes used in model */

/* Flattened Modelica model:

function Buildings.Utilities.Math.Functions.BaseClasses.der_spliceFunction
discrete input Real pos;
discrete input Real neg;
discrete input Real x;
discrete input Real deltax(start = 1);
discrete input Real dpos;
discrete input Real dneg;
discrete input Real dx;
discrete input Real ddeltax(start = 0);
discrete output Real out;
protected 
discrete Real scaledX;
discrete Real scaledX1;
discrete Real dscaledX1;
discrete Real y;
constant Real asin1 = 1.5707963267948966;
public 
algorithm 
scaledX1 := x/deltax;
if (scaledX1 <= -0.99999999999) then 
out := dneg;
elseif (scaledX1 >= 0.9999999999) then 
out := dpos;
else
scaledX := scaledX1*asin1;
dscaledX1 := (dx-scaledX1*ddeltax)/deltax;
y := (tanh(tan(scaledX))+1)/2;
out := dpos*y+(1-y)*dneg;
out := out+(pos-neg)*dscaledX1*asin1/2/(cosh(tan(scaledX))*cos(scaledX))^2;
end if;
end Buildings.Utilities.Math.Functions.BaseClasses.der_spliceFunction;

  */
DYMOLA_STATIC double   Buildings_Utilities_Math_Functions_BaseClasses_derx_0spliceFunction
  (double  pos0_0, double  neg0_0, double  x0_0, double  deltax0_0, double  
  dpos0_0, double  dneg0_0, double  dx0_0, double  ddeltax0_0) {
  PushContext("Buildings.Utilities.Math.Functions.BaseClasses.der_spliceFunction")
  {
    /* Declare outputs and temporaries */
    double   out0_0;
    double   scaledX0_0;
    double   scaledX10_0;
    double   dscaledX10_0;
    double   y0_0;
    double   asin10_0;
    out0_0=0;
    scaledX0_0=0;
    scaledX10_0=0;
    dscaledX10_0=0;
    y0_0=0;
    asin10_0 = 1.5707963267948966;
    /* Start of real code */
      scaledX10_0 = divmacro(x0_0,"x",deltax0_0,"deltax");
      if (scaledX10_0 <= -0.99999999999) {
        out0_0 = dneg0_0;
      }
      else if (scaledX10_0 >= 0.9999999999) {
        out0_0 = dpos0_0;
      }
      else{
        scaledX0_0 = scaledX10_0*asin10_0;
        dscaledX10_0 = divmacro(dx0_0-scaledX10_0*ddeltax0_0,"dx-scaledX1*ddeltax",
          deltax0_0,"deltax");
        y0_0 = (tanh(tan(scaledX0_0))+1)/(double)(2);
        out0_0 = dpos0_0*y0_0+(1-y0_0)*dneg0_0;
        out0_0 = out0_0+divmacro((pos0_0-neg0_0)*dscaledX10_0*asin10_0/(double)(2),
          "(pos-neg)*dscaledX1*asin1/2",sqr(cosh(tan(scaledX0_0))*cos(scaledX0_0)),
          "(cosh(tan(scaledX))*cos(scaledX))^2");
      }
    /* Output section */
    PopContext()
    return out0_0;
  }}

/* Flattened Modelica model:

function Buildings.Utilities.Math.Functions.spliceFunction
discrete input Real pos "Argument of x > 0";
discrete input Real neg "Argument of x < 0";
discrete input Real x "Independent value";
discrete input Real deltax "Half width of transition interval";
discrete output Real out "Smoothed value";
protected 
discrete Real scaledX1;
discrete Real y;
constant Real asin1 = 1.5707963267948966;
public 
algorithm 
scaledX1 := x/deltax;
if (scaledX1 <= -0.999999999) then 
out := neg;
elseif (scaledX1 >= 0.999999999) then 
out := pos;
else
y := (tanh(tan(scaledX1*asin1))+1)/2;
out := pos*y+(1-y)*neg;
end if;
annotation(derivative=Buildings.Utilities.Math.Functions.BaseClasses.der_spliceFunction, smoothOrder=1);
end Buildings.Utilities.Math.Functions.spliceFunction;

  */
DYMOLA_STATIC double   Buildings_Utilities_Math_Functions_spliceFunction(double 
   pos0_0, double  neg0_0, double  x0_0, double  deltax0_0) {
  PushContext("Buildings.Utilities.Math.Functions.spliceFunction")
  {
    /* Declare outputs and temporaries */
    double   out0_0;
    double   scaledX10_0;
    double   y0_0;
    double   asin10_0;
    out0_0=0;
    scaledX10_0=0;
    y0_0=0;
    asin10_0 = 1.5707963267948966;
    /* Start of real code */
      scaledX10_0 = divmacro(x0_0,"x",deltax0_0,"deltax");
      if (scaledX10_0 <= -0.999999999) {
        out0_0 = neg0_0;
      }
      else if (scaledX10_0 >= 0.999999999) {
        out0_0 = pos0_0;
      }
      else{
        y0_0 = (tanh(tan(scaledX10_0*asin10_0))+1)/(double)(2);
        out0_0 = pos0_0*y0_0+(1-y0_0)*neg0_0;
      }
    /* Output section */
    PopContext()
    return out0_0;
  }}

/* Flattened Modelica model:

function Modelica.Blocks.Sources.CombiTimeTable.getDerTableValue
input Modelica.Blocks.Types.ExternalCombiTimeTable tableID;
input Integer icol;
discrete input Real timeIn(unit = "s");
discrete input Real nextTimeEvent(unit = "s");
discrete input Real pre_nextTimeEvent(unit = "s");
discrete input Real tableAvailable "Dummy input to ensure correct sorting of function calls";
discrete input Real der_timeIn;
discrete output Real der_y;

external "C" der_y = ModelicaStandardTables_CombiTimeTable_getDerValue(tableID, icol, timeIn, nextTimeEvent, pre_nextTimeEvent, der_timeIn);
annotation(Library={"ModelicaStandardTables"}, LibraryDirectory="C:/Program Files (x86)/Dymola 2016 FD01/Modelica/Library/Modelica 3.2.1/Resources/Library");
end Modelica.Blocks.Sources.CombiTimeTable.getDerTableValue;

  */
DYMOLA_STATIC double   Modelica_Blocks_Sources_CombiTimeTable_getDerTableValue_M
  (struct DymStruc0 tableID0_0, int  icol0_0, double  timeIn0_0, double  
  nextTimeEvent0_0, double  prex_0nextTimeEvent, double  tableAvailable0_0, 
  double  derx_0timeIn) {
  PushContext("Modelica.Blocks.Sources.CombiTimeTable.getDerTableValue")
  {
    /* Declare outputs and temporaries */
    double   derx_0y;
    derx_0y=0;
    /* Start of real code */
    {
      extern double (ModelicaStandardTables_CombiTimeTable_getDerValue)(void*, 
        int , double , double , double , double );
      derx_0y = (ModelicaStandardTables_CombiTimeTable_getDerValue)(
        externalTable_[tableID0_0.id_0member].obj_, icol0_0, timeIn0_0, 
        nextTimeEvent0_0, prex_0nextTimeEvent, derx_0timeIn);
      }
    /* Output section */
    PopContext()
    return derx_0y;
  }}

/* Flattened Modelica model:

function Modelica.Blocks.Sources.CombiTimeTable.getNextTimeEvent
input Modelica.Blocks.Types.ExternalCombiTimeTable tableID;
discrete input Real timeIn(unit = "s");
discrete input Real tableAvailable "Dummy input to ensure correct sorting of function calls";
discrete output Real nextTimeEvent(unit = "s") "Next time event in table";

external "C" nextTimeEvent = ModelicaStandardTables_CombiTimeTable_nextTimeEvent(tableID, timeIn);
annotation(Library={"ModelicaStandardTables"}, LibraryDirectory="C:/Program Files (x86)/Dymola 2016 FD01/Modelica/Library/Modelica 3.2.1/Resources/Library");
end Modelica.Blocks.Sources.CombiTimeTable.getNextTimeEvent;

  */
DYMOLA_STATIC double   Modelica_Blocks_Sources_CombiTimeTable_getNextTimeEvent_M
  (struct DymStruc0 tableID0_0, double  timeIn0_0, double  tableAvailable0_0) {
  PushContext("Modelica.Blocks.Sources.CombiTimeTable.getNextTimeEvent")
  {
    /* Declare outputs and temporaries */
    double   nextTimeEvent0_0;
    nextTimeEvent0_0=0;
    /* Start of real code */
    {
      extern double (ModelicaStandardTables_CombiTimeTable_nextTimeEvent)(void*,
         double );
      nextTimeEvent0_0 = (ModelicaStandardTables_CombiTimeTable_nextTimeEvent)(
        externalTable_[tableID0_0.id_0member].obj_, timeIn0_0);
      }
    /* Output section */
    PopContext()
    return nextTimeEvent0_0;
  }}

/* Flattened Modelica model:

function Modelica.Blocks.Sources.CombiTimeTable.getTableTimeTmax
input Modelica.Blocks.Types.ExternalCombiTimeTable tableID;
discrete input Real tableAvailable "Dummy input to ensure correct sorting of function calls";
discrete output Real timeMax(unit = "s") "Maximum time value in table";

external "C" timeMax = ModelicaStandardTables_CombiTimeTable_maximumTime(tableID);
annotation(Library={"ModelicaStandardTables"}, LibraryDirectory="C:/Program Files (x86)/Dymola 2016 FD01/Modelica/Library/Modelica 3.2.1/Resources/Library");
end Modelica.Blocks.Sources.CombiTimeTable.getTableTimeTmax;

  */
DYMOLA_STATIC double   Modelica_Blocks_Sources_CombiTimeTable_getTableTimeTmax_M
  (struct DymStruc0 tableID0_0, double  tableAvailable0_0) {
  PushContext("Modelica.Blocks.Sources.CombiTimeTable.getTableTimeTmax")
  {
    /* Declare outputs and temporaries */
    double   timeMax0_0;
    timeMax0_0=0;
    /* Start of real code */
    {
      extern double (ModelicaStandardTables_CombiTimeTable_maximumTime)(void*);
      timeMax0_0 = (ModelicaStandardTables_CombiTimeTable_maximumTime)(
        externalTable_[tableID0_0.id_0member].obj_);
      }
    /* Output section */
    PopContext()
    return timeMax0_0;
  }}

/* Flattened Modelica model:

function Modelica.Blocks.Sources.CombiTimeTable.getTableTimeTmin
input Modelica.Blocks.Types.ExternalCombiTimeTable tableID;
discrete input Real tableAvailable "Dummy input to ensure correct sorting of function calls";
discrete output Real timeMin(unit = "s") "Minimum time value in table";

external "C" timeMin = ModelicaStandardTables_CombiTimeTable_minimumTime(tableID);
annotation(Library={"ModelicaStandardTables"}, LibraryDirectory="C:/Program Files (x86)/Dymola 2016 FD01/Modelica/Library/Modelica 3.2.1/Resources/Library");
end Modelica.Blocks.Sources.CombiTimeTable.getTableTimeTmin;

  */
DYMOLA_STATIC double   Modelica_Blocks_Sources_CombiTimeTable_getTableTimeTmin_M
  (struct DymStruc0 tableID0_0, double  tableAvailable0_0) {
  PushContext("Modelica.Blocks.Sources.CombiTimeTable.getTableTimeTmin")
  {
    /* Declare outputs and temporaries */
    double   timeMin0_0;
    timeMin0_0=0;
    /* Start of real code */
    {
      extern double (ModelicaStandardTables_CombiTimeTable_minimumTime)(void*);
      timeMin0_0 = (ModelicaStandardTables_CombiTimeTable_minimumTime)(
        externalTable_[tableID0_0.id_0member].obj_);
      }
    /* Output section */
    PopContext()
    return timeMin0_0;
  }}

/* Flattened Modelica model:

function Modelica.Blocks.Sources.CombiTimeTable.getTableValue
input Modelica.Blocks.Types.ExternalCombiTimeTable tableID;
input Integer icol;
discrete input Real timeIn(unit = "s");
discrete input Real nextTimeEvent(unit = "s");
discrete input Real pre_nextTimeEvent(unit = "s");
discrete input Real tableAvailable "Dummy input to ensure correct sorting of function calls";
discrete output Real y;

external "C" y = ModelicaStandardTables_CombiTimeTable_getValue(tableID, icol, timeIn, nextTimeEvent, pre_nextTimeEvent);
annotation(derivative(noDerivative=nextTimeEvent, noDerivative=pre_nextTimeEvent, noDerivative=tableAvailable)=Modelica.Blocks.Sources.CombiTimeTable.getDerTableValue, Library={"ModelicaStandardTables"}, LibraryDirectory="C:/Program Files (x86)/Dymola 2016 FD01/Modelica/Library/Modelica 3.2.1/Resources/Library");
end Modelica.Blocks.Sources.CombiTimeTable.getTableValue;

  */
DYMOLA_STATIC double   Modelica_Blocks_Sources_CombiTimeTable_getTableValue_M(
  struct DymStruc0 tableID0_0, int  icol0_0, double  timeIn0_0, double  
  nextTimeEvent0_0, double  prex_0nextTimeEvent, double  tableAvailable0_0) {
  PushContext("Modelica.Blocks.Sources.CombiTimeTable.getTableValue")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    y0_0=0;
    /* Start of real code */
    {
      extern double (ModelicaStandardTables_CombiTimeTable_getValue)(void*, int ,
         double , double , double );
      y0_0 = (ModelicaStandardTables_CombiTimeTable_getValue)(externalTable_[
        tableID0_0.id_0member].obj_, icol0_0, timeIn0_0, nextTimeEvent0_0, 
        prex_0nextTimeEvent);
      }
    /* Output section */
    PopContext()
    return y0_0;
  }}

/* Flattened Modelica model:

function Modelica.Blocks.Sources.CombiTimeTable.readTableData
input Modelica.Blocks.Types.ExternalCombiTimeTable tableID;
input Boolean forceRead(start = false) "= true: Force reading of table data; = false: Only read, if not yet read.";
discrete output Real readSuccess "Table read success";
input Boolean verboseRead "= true: Print info message; = false: No info message";

external "C" readSuccess = ModelicaStandardTables_CombiTimeTable_read(tableID, forceRead, verboseRead);
annotation(Library={"ModelicaStandardTables"}, LibraryDirectory="C:/Program Files (x86)/Dymola 2016 FD01/Modelica/Library/Modelica 3.2.1/Resources/Library");
end Modelica.Blocks.Sources.CombiTimeTable.readTableData;

  */
DYMOLA_STATIC double   Modelica_Blocks_Sources_CombiTimeTable_readTableData_M(
  struct DymStruc0 tableID0_0, int  forceRead0_0, int  verboseRead0_0) {
  PushContext("Modelica.Blocks.Sources.CombiTimeTable.readTableData")
  {
    /* Declare outputs and temporaries */
    double   readSuccess0_0;
    readSuccess0_0=0;
    /* Start of real code */
    {
      extern double (ModelicaStandardTables_CombiTimeTable_read)(void*, int , 
        int );
      readSuccess0_0 = (ModelicaStandardTables_CombiTimeTable_read)(
        externalTable_[tableID0_0.id_0member].obj_, forceRead0_0, verboseRead0_0);
      }
    /* Output section */
    PopContext()
    return readSuccess0_0;
  }}

/* Flattened Modelica model:

function Modelica.Blocks.Tables.CombiTable1D.getDerTableValue
input Modelica.Blocks.Types.ExternalCombiTable1D tableID;
input Integer icol;
discrete input Real u;
discrete input Real tableAvailable "Dummy input to ensure correct sorting of function calls";
discrete input Real der_u;
discrete output Real der_y;

external "C" der_y = ModelicaStandardTables_CombiTable1D_getDerValue(tableID, icol, u, der_u);
annotation(Library={"ModelicaStandardTables"}, LibraryDirectory="C:/Program Files (x86)/Dymola 2016 FD01/Modelica/Library/Modelica 3.2.1/Resources/Library");
end Modelica.Blocks.Tables.CombiTable1D.getDerTableValue;

  */
DYMOLA_STATIC double   Modelica_Blocks_Tables_CombiTable1D_getDerTableValue_M(
  struct DymStruc0 tableID0_0, int  icol0_0, double  u0_0, double  
  tableAvailable0_0, double  derx_0u) {
  PushContext("Modelica.Blocks.Tables.CombiTable1D.getDerTableValue")
  {
    /* Declare outputs and temporaries */
    double   derx_0y;
    derx_0y=0;
    /* Start of real code */
    {
      extern double (ModelicaStandardTables_CombiTable1D_getDerValue)(void*, int ,
         double , double );
      derx_0y = (ModelicaStandardTables_CombiTable1D_getDerValue)(
        externalTable_[tableID0_0.id_0member].obj_, icol0_0, u0_0, derx_0u);
      }
    /* Output section */
    PopContext()
    return derx_0y;
  }}

/* Flattened Modelica model:

function Modelica.Blocks.Tables.CombiTable1D.getTableValue
input Modelica.Blocks.Types.ExternalCombiTable1D tableID;
input Integer icol;
discrete input Real u;
discrete input Real tableAvailable "Dummy input to ensure correct sorting of function calls";
discrete output Real y;

external "C" y = ModelicaStandardTables_CombiTable1D_getValue(tableID, icol, u);
annotation(derivative(noDerivative=tableAvailable)=Modelica.Blocks.Tables.CombiTable1D.getDerTableValue, Library={"ModelicaStandardTables"}, LibraryDirectory="C:/Program Files (x86)/Dymola 2016 FD01/Modelica/Library/Modelica 3.2.1/Resources/Library");
end Modelica.Blocks.Tables.CombiTable1D.getTableValue;

  */
DYMOLA_STATIC double   Modelica_Blocks_Tables_CombiTable1D_getTableValue_M(
  struct DymStruc0 tableID0_0, int  icol0_0, double  u0_0, double  
  tableAvailable0_0) {
  PushContext("Modelica.Blocks.Tables.CombiTable1D.getTableValue")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    y0_0=0;
    /* Start of real code */
    {
      extern double (ModelicaStandardTables_CombiTable1D_getValue)(void*, int , 
        double );
      y0_0 = (ModelicaStandardTables_CombiTable1D_getValue)(externalTable_[
        tableID0_0.id_0member].obj_, icol0_0, u0_0);
      }
    /* Output section */
    PopContext()
    return y0_0;
  }}

/* Flattened Modelica model:

function Modelica.Blocks.Types.ExternalCombiTable1D
input String tableName "Table name";
input String fileName "File name";
discrete input Real table[:, :];
input Integer columns[:];
input Modelica.Blocks.Types.Smoothness smoothness;
output Modelica.Blocks.Types.ExternalCombiTable1D externalCombiTable1D;

external "C" externalCombiTable1D = ModelicaStandardTables_CombiTable1D_init(tableName, fileName, table, size(table, 1), size(table, 2), columns, size(columns, 1), smoothness);
annotation(Library={"ModelicaStandardTables"}, LibraryDirectory="C:/Program Files (x86)/Dymola 2016 FD01/Modelica/Library/Modelica 3.2.1/Resources/Library");
end Modelica.Blocks.Types.ExternalCombiTable1D;

  */
DYMOLA_STATIC struct DymStruc0  Modelica_Blocks_Types_ExternalCombiTable1D_M(
  const char*  tableName0_0, const char*  fileName0_0, RealArray   table0_0, 
  IntegerArray   columns0_0, int  smoothness0_0, int id_, int alwaysMakeNew_) {
  PushContext("Modelica.Blocks.Types.ExternalCombiTable1D")
  {
    /* Declare outputs and temporaries */
    struct DymStruc0  externalCombiTable1D0_0;
    externalCombiTable1D0_0.id_0member=0;
    /* Start of real code */
    {
      extern void* (ModelicaStandardTables_CombiTable1D_init)(const char* , 
        const char* , double  const *, size_t, size_t, int  const *, size_t, int );
      externalCombiTable1D0_0.id_0member=id_;
      if (externalTable_[id_].destructor_ && externalTable_[id_].obj_ && alwaysMakeNew_) {
      void*x_=externalTable_[id_].obj_;
      externalTable_[id_].obj_=0;
      (*(externalTable_[id_].destructor_))(x_);
      } else if (!externalTable_[id_].destructor_) {externalTable_[id_].obj_=0;}
      externalTable_[id_].destructor_=Modelica_Blocks_Types_ExternalCombiTable1D_destructor_M;

        if (!externalTable_[id_].obj_) externalTable_[id_].obj_ = (
        ModelicaStandardTables_CombiTable1D_init)(tableName0_0, fileName0_0, 
        table0_0.data, table0_0.dims[1-1], table0_0.dims[2-1], columns0_0.data, 
        columns0_0.dims[1-1], smoothness0_0);
      }
    /* Output section */
    PopContext()
    return externalCombiTable1D0_0;
  }}

/* Flattened Modelica model:

function Modelica.Blocks.Types.ExternalCombiTable1D.destructor
input Modelica.Blocks.Types.ExternalCombiTable1D externalCombiTable1D;

external "C" ModelicaStandardTables_CombiTable1D_close(externalCombiTable1D);
annotation(Library={"ModelicaStandardTables"}, LibraryDirectory="C:/Program Files (x86)/Dymola 2016 FD01/Modelica/Library/Modelica 3.2.1/Resources/Library");
end Modelica.Blocks.Types.ExternalCombiTable1D.destructor;

  */
DYMOLA_STATIC void Modelica_Blocks_Types_ExternalCombiTable1D_destructor_M(
  void* externalCombiTable1D0_0) {
  PushContext("Modelica.Blocks.Types.ExternalCombiTable1D.destructor")
  {
    /* Declare outputs and temporaries */
    /* Start of real code */
    {
      extern void (ModelicaStandardTables_CombiTable1D_close)(void*);
      (ModelicaStandardTables_CombiTable1D_close)(externalCombiTable1D0_0);
      }
    /* Output section */
    PopContext()
    return ;
  }}

/* Flattened Modelica model:

function Modelica.Blocks.Types.ExternalCombiTimeTable
input String tableName "Table name";
input String fileName "File name";
discrete input Real table[:, :];
discrete input Real startTime(unit = "s");
input Integer columns[:];
input Modelica.Blocks.Types.Smoothness smoothness;
input Modelica.Blocks.Types.Extrapolation extrapolation;
output Modelica.Blocks.Types.ExternalCombiTimeTable externalCombiTimeTable;

external "C" externalCombiTimeTable = ModelicaStandardTables_CombiTimeTable_init(tableName, fileName, table, size(table, 1), size(table, 2), startTime, columns, size(columns, 1), smoothness, extrapolation);
annotation(Library={"ModelicaStandardTables"}, LibraryDirectory="C:/Program Files (x86)/Dymola 2016 FD01/Modelica/Library/Modelica 3.2.1/Resources/Library");
end Modelica.Blocks.Types.ExternalCombiTimeTable;

  */
DYMOLA_STATIC struct DymStruc0  Modelica_Blocks_Types_ExternalCombiTimeTable_M(
  const char*  tableName0_0, const char*  fileName0_0, RealArray   table0_0, 
  double  startTime0_0, IntegerArray   columns0_0, int  smoothness0_0, int  
  extrapolation0_0, int id_, int alwaysMakeNew_) {
  PushContext("Modelica.Blocks.Types.ExternalCombiTimeTable")
  {
    /* Declare outputs and temporaries */
    struct DymStruc0  externalCombiTimeTable0_0;
    externalCombiTimeTable0_0.id_0member=0;
    /* Start of real code */
    {
      extern void* (ModelicaStandardTables_CombiTimeTable_init)(const char* , 
        const char* , double  const *, size_t, size_t, double , int  const *, 
        size_t, int , int );
      externalCombiTimeTable0_0.id_0member=id_;
      if (externalTable_[id_].destructor_ && externalTable_[id_].obj_ && alwaysMakeNew_) {
      void*x_=externalTable_[id_].obj_;
      externalTable_[id_].obj_=0;
      (*(externalTable_[id_].destructor_))(x_);
      } else if (!externalTable_[id_].destructor_) {externalTable_[id_].obj_=0;}
      externalTable_[id_].destructor_=Modelica_Blocks_Types_ExternalCombiTimeTable_destructor_M;

        if (!externalTable_[id_].obj_) externalTable_[id_].obj_ = (
        ModelicaStandardTables_CombiTimeTable_init)(tableName0_0, fileName0_0, 
        table0_0.data, table0_0.dims[1-1], table0_0.dims[2-1], startTime0_0, 
        columns0_0.data, columns0_0.dims[1-1], smoothness0_0, extrapolation0_0);
      }
    /* Output section */
    PopContext()
    return externalCombiTimeTable0_0;
  }}

/* Flattened Modelica model:

function Modelica.Blocks.Types.ExternalCombiTimeTable.destructor
input Modelica.Blocks.Types.ExternalCombiTimeTable externalCombiTimeTable;

external "C" ModelicaStandardTables_CombiTimeTable_close(externalCombiTimeTable);
annotation(Library={"ModelicaStandardTables"}, LibraryDirectory="C:/Program Files (x86)/Dymola 2016 FD01/Modelica/Library/Modelica 3.2.1/Resources/Library");
end Modelica.Blocks.Types.ExternalCombiTimeTable.destructor;

  */
DYMOLA_STATIC void Modelica_Blocks_Types_ExternalCombiTimeTable_destructor_M(
  void* externalCombiTimeTable0_0) {
  PushContext("Modelica.Blocks.Types.ExternalCombiTimeTable.destructor")
  {
    /* Declare outputs and temporaries */
    /* Start of real code */
    {
      extern void (ModelicaStandardTables_CombiTimeTable_close)(void*);
      (ModelicaStandardTables_CombiTimeTable_close)(externalCombiTimeTable0_0);
      }
    /* Output section */
    PopContext()
    return ;
  }}
/* DSblock C-code: */

BreakSectionFunctionDef(1)
BreakSectionFunctionDef(0)
#define NX_    0
#define NX2_   2
#define NU_    0
#define NY_    0
#define NW_    178
#define NP_    58
#define NPS_   0
#define MAXAuxStr_   8
#define MAXAuxStrLen_   500
#define NHash1_ -1447421888
#define NHash2_ -1805939697
#define NHash3_ 0
#define NI_    0
#define NRelF_ 0
#define NRel_  0
#define NTim_  1
#define NSamp_ 0
#define NCons_ 0
#define NA_    34
#define SizePre_ 1
#define SizeEq_ 4
#define SizeDelay_ 0
#define QNLmax_ 1
#define MAXAux 1
#define NrDymolaTimers_ 0
#define NWhen_ 1
#define NCheckIf_ 0
#define NGlobalHelp_ 118
#define NGlobalHelpI_ 33
#ifndef NExternalObject_
#define NExternalObject_ 2
#endif
#include <moutil.c>
PreNonAliasDef(0)
PreNonAliasDef(1)
PreNonAliasDef(2)
PreNonAliasDef(3)
PreNonAliasDef(4)
PreNonAliasDef(5)
#if !defined(DYM2CCUR)
 DYMOLA_STATIC const char*modelName="DC_Tool.Converters.Examples.ConverterTesting";
#endif
DYMOLA_STATIC const char*usedLibraries[]={0};
DYMOLA_STATIC const char*dllLibraryPath[]={0};
DYMOLA_STATIC const char*default_dymosim_license_filename=
 "c:/users/daniel gerber/appdata/roaming/dynasim/dymola.lic";
#include <dsblock1.c>

/* Define variable names. */

#define Sections_

TranslatedEquations

InitialSection
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,0) = true;
DYNX(W_,1) = false;
DYNX(W_,10) = 3;
DYNX(W_,21) = 1E-010;
DYNX(W_,22) = 0.9999999999;
DYNX(W_,39) = false;
DYNX(W_,79) = true;
DYNX(W_,80) = 13;
DYNX(W_,107) = 1;
DYNX(W_,144) = 13;
#endif
DYNSetAuxString(did_, "C:/Users/Daniel Gerber/Desktop/LBL Sync Windows/ModelicaFiles/DC_Tool/Scripts/ModelicaMatDCToolTest.mat",
   0);
DYNSetAuxString(did_, "LoadData", 1);
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,9) = false;
DYNX(W_,11) = 48;
#endif
DYNSetAuxString(did_, "", 2);
DYNSetAuxString(did_, "", 3);
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,40) = true;
DYNX(W_,81) = 0.0;
DYNX(W_,83) = 0.0;
DYNX(W_,85) = 0.0;
DYNX(W_,87) = 0.0;
DYNX(W_,89) = 0.0;
DYNX(W_,91) = 0.0;
DYNX(W_,93) = 0.0;
DYNX(W_,95) = 0.0;
DYNX(W_,97) = 0.0;
DYNX(W_,99) = 0.0;
DYNX(W_,101) = 0.0;
DYNX(W_,103) = 0.0;
DYNX(W_,105) = 0.0;
#endif
DYNSetAuxString(did_, "NoName", 4);
DYNSetAuxString(did_, "NoName", 5);
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,135) = 2;
#endif
DYNSetAuxString(did_, "LoadData", 6);
DYNSetAuxString(did_, "C:/Users/Daniel Gerber/Desktop/LBL Sync Windows/ModelicaFiles/DC_Tool/Scripts/ModelicaMatDCToolTest.mat",
   7);
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,12) = 1;
DYNX(W_,36) = -1.0;
DYNX(W_,37) = false;
DYNX(W_,38) = true;
DYNX(W_,108) = false;
DYNX(W_,136) = 1;
DYNX(W_,157) = true;
DYNX(W_,158) = 2;
DYNX(W_,13) = 0.0;
DYNX(W_,8) = 0;
DYNX(W_,48) = 0.0;
DYNX(W_,15) = 0.0;
DYNX(W_,19) = 1;
DYNX(W_,20) = 1;
DYNX(W_,51) = 0.0;
DYNX(W_,28) = 0.0;
DYNX(W_,18) = 0.0;
#endif
BoundParameterSection
AssertModelica4(fabs(DYNX(DP_,12)) < 1E-010,"abs(load1.P_nominal) < 1E-010", 
  StringAdd(StringAdd("*** Warning: P_nominal = ",Real2String2(DYNX(DP_,12), 
  true, 0)),", but this value will be ignored."), 1,DYNX(did_->helpvari_vec,0));
PopAllMarks();
DYNX(W_,57) = DYNX(DP_,16);
DYNX(W_,58) = DYNX(DP_,17);
DYNX(W_,59) = DYNX(DP_,18);
DYNX(W_,60) = DYNX(DP_,19);
DYNX(W_,61) = DYNX(DP_,20);
DYNX(W_,62) = DYNX(DP_,21);
DYNX(W_,63) = DYNX(DP_,22);
DYNX(W_,64) = DYNX(DP_,23);
DYNX(W_,65) = DYNX(DP_,24);
DYNX(W_,66) = DYNX(DP_,25);
DYNX(W_,67) = DYNX(DP_,26);
DYNX(W_,68) = DYNX(DP_,27);
DYNX(W_,69) = DYNX(DP_,28);
DYNX(W_,70) = DYNX(DP_,29);
DYNX(W_,71) = DYNX(DP_,30);
DYNX(W_,72) = DYNX(DP_,31);
DYNX(W_,73) = DYNX(DP_,32);
DYNX(W_,74) = DYNX(DP_,33);
DYNX(W_,75) = DYNX(DP_,34);
DYNX(W_,76) = DYNX(DP_,35);
DYNX(W_,77) = DYNX(DP_,36);
DYNX(W_,78) = DYNX(DP_,37);
DYNX(W_,82) = DYNX(DP_,38);
DYNX(W_,84) = DYNX(DP_,38);
DYNX(W_,86) = DYNX(DP_,38);
DYNX(W_,88) = DYNX(DP_,38);
DYNX(W_,90) = DYNX(DP_,38);
DYNX(W_,92) = DYNX(DP_,38);
DYNX(W_,94) = DYNX(DP_,38);
DYNX(W_,96) = DYNX(DP_,38);
DYNX(W_,98) = DYNX(DP_,38);
DYNX(W_,100) = DYNX(DP_,38);
DYNX(W_,102) = DYNX(DP_,38);
DYNX(W_,104) = DYNX(DP_,38);
DYNX(W_,106) = DYNX(DP_,38);
DYNX(W_,109) = DYNX(W_,57)+DYNX(W_,81)-1;
DYNX(W_,110) = DYNX(W_,58)+DYNX(W_,82);
DYNX(W_,111) = DYNX(W_,57)+DYNX(W_,83);
DYNX(W_,112) = DYNX(W_,58)+DYNX(W_,84);
DYNX(W_,113) = DYNX(W_,59)+DYNX(W_,85);
DYNX(W_,114) = DYNX(W_,60)+DYNX(W_,86);
DYNX(W_,115) = DYNX(W_,61)+DYNX(W_,87);
DYNX(W_,116) = DYNX(W_,62)+DYNX(W_,88);
DYNX(W_,117) = DYNX(W_,63)+DYNX(W_,89);
DYNX(W_,118) = DYNX(W_,64)+DYNX(W_,90);
DYNX(W_,119) = DYNX(W_,65)+DYNX(W_,91);
DYNX(W_,120) = DYNX(W_,66)+DYNX(W_,92);
DYNX(W_,121) = DYNX(W_,67)+DYNX(W_,93);
DYNX(W_,122) = DYNX(W_,68)+DYNX(W_,94);
DYNX(W_,123) = DYNX(W_,69)+DYNX(W_,95);
DYNX(W_,124) = DYNX(W_,70)+DYNX(W_,96);
DYNX(W_,125) = DYNX(W_,71)+DYNX(W_,97);
DYNX(W_,126) = DYNX(W_,72)+DYNX(W_,98);
DYNX(W_,127) = DYNX(W_,73)+DYNX(W_,99);
DYNX(W_,128) = DYNX(W_,74)+DYNX(W_,100);
DYNX(W_,129) = DYNX(W_,75)+DYNX(W_,101);
DYNX(W_,130) = DYNX(W_,76)+DYNX(W_,102);
DYNX(W_,131) = DYNX(W_,77)+DYNX(W_,103);
DYNX(W_,132) = DYNX(W_,78)+DYNX(W_,104);
DYNX(W_,133) = 1.0+DYNX(W_,77)+DYNX(W_,105);
DYNX(W_,134) = DYNX(W_,78)+DYNX(W_,106);
DYNX(W_,159) =  -DYNX(DP_,0);
DYNX(W_,162) = DYNX(DP_,57);
DYNX(W_,163) = DYNX(DP_,57);
DYNX(W_,164) = DYNX(DP_,57);
DYNX(W_,165) = DYNX(DP_,57);
DYNX(W_,166) = DYNX(DP_,57);
DYNX(W_,167) = DYNX(DP_,57);
DYNX(W_,168) = DYNX(DP_,57);
DYNX(W_,169) = DYNX(DP_,57);
DYNX(W_,170) = DYNX(DP_,57);
DYNX(W_,171) = DYNX(DP_,57);
DYNX(W_,172) = DYNX(DP_,57);
DYNX(W_,173) = DYNX(DP_,57);
DYNX(W_,174) = DYNX(DP_,57);
InitialBoundSection
{
  struct DymStruc0 dummy_DymStruc0;
  dummy_DymStruc0 = (PushModelContext(1,"Modelica.Blocks.Types.ExternalCombiTimeTable(\"LoadData\", \"C:/Users/Daniel Gerber/Desktop/LBL Sync Windows/ModelicaFiles/DC_Tool/Scripts/ModelicaMatDCToolTest.mat\", dataTable1.table, dataTable1.startTime, dataTable1.columns, Modelica.Blocks.Types.Smoothness.ContinuousDerivative, dataTable1.extrapolation, 0, 1)")
    Modelica_Blocks_Types_ExternalCombiTimeTable_M("LoadData", "C:/Users/Daniel Gerber/Desktop/LBL Sync Windows/ModelicaFiles/DC_Tool/Scripts/ModelicaMatDCToolTest.mat",
     RealTemporaryDense( (Real*)(0), 2, 0, 2), DYNX(W_,159), IntegerTemporaryDense( 
    &DYNX(DP_,43), 1, 13), 2, (Integer)(DYNX(DP_,56)), 0, 1));
  DYNX(W_,175) = dummy_DymStruc0.id_0member;
PopAllMarks();
}
{
  struct DymStruc0 dummy_DymStruc0;
  dummy_DymStruc0 = (PushModelContext(1,"Modelica.Blocks.Types.ExternalCombiTable1D(\"NoName\", \"NoName\", aC1DC2.tab.tab.table, aC1DC2.tab.tab.columns, Modelica.Blocks.Types.Smoothness.LinearSegments, 1, 1)")
    Modelica_Blocks_Types_ExternalCombiTable1D_M("NoName", "NoName", 
    RealTemporaryDense( &DYNX(W_,109), 2, 13, 2), IntegerTemporaryDense( 
    &DYNX(W_,135), 1, 1), 1, 1, 1));
  DYNX(W_,137) = dummy_DymStruc0.id_0member;
PopAllMarks();
}
BoundParameterSection
DYNX(DYNhelp,0) = cos(DYNX(DP_,11));
DYNX(W_,5) = DYNX(DP_,10)*DYNX(DYNhelp,0);
DYNX(DYNhelp,1) = sin(DYNX(DP_,11));
DYNX(W_,6) = DYNX(DP_,10)*DYNX(DYNhelp,1);
DYNX(W_,43) = DYNX(DP_,15)*DYNX(DP_,3);
DYNX(W_,23) = fabs(DYNX(DP_,14));
DYNX(W_,31) = divmacro(DYNX(W_,5)*DYNX(W_,5)+DYNX(W_,6)*DYNX(W_,6),
  "source1.terminal.v[1]*source1.terminal.v[1]+source1.terminal.v[2]*source1.terminal.v[2]",
  powmacro(1.0000000000000002E-010+(DYNX(W_,5)*DYNX(W_,5)+DYNX(W_,6)*DYNX(W_,6))
  *(DYNX(W_,5)*DYNX(W_,5)+DYNX(W_,6)*DYNX(W_,6)),"1.0000000000000002E-010+(source1.terminal.v[1]*source1.terminal.v[1]+source1.terminal.v[2]*source1.terminal.v[2])*(source1.terminal.v[1]*source1.terminal.v[1]+source1.terminal.v[2]*source1.terminal.v[2])",
  0.25,"0.25"),"(1.0000000000000002E-010+(source1.terminal.v[1]*source1.terminal.v[1]+source1.terminal.v[2]*source1.terminal.v[2])*(source1.terminal.v[1]*source1.terminal.v[1]+source1.terminal.v[2]*source1.terminal.v[2]))^0.25");
DYNX(W_,46) = divmacro(DYNX(DP_,14),"aC1DC2.V2",DYNX(W_,31),"aC1DC2.v_n");
InitialSection
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,24) = 0;
DYNX(W_,25) = 0;
DYNX(W_,29) = 0;
DYNX(W_,176) = 0;
#endif
InitialSection
InitialStartSection
InitialSection
DefaultSection
InitializeData(0)
InitialSection
DYNX(Aux_,0) = DYNX(W_,176);
InitialSection
InitialSection2
DYNX(W_,57) = DYNX(DP_,16);
DYNX(W_,58) = DYNX(DP_,17);
DYNX(W_,59) = DYNX(DP_,18);
DYNX(W_,60) = DYNX(DP_,19);
DYNX(W_,61) = DYNX(DP_,20);
DYNX(W_,62) = DYNX(DP_,21);
DYNX(W_,63) = DYNX(DP_,22);
DYNX(W_,64) = DYNX(DP_,23);
DYNX(W_,65) = DYNX(DP_,24);
DYNX(W_,66) = DYNX(DP_,25);
DYNX(W_,67) = DYNX(DP_,26);
DYNX(W_,68) = DYNX(DP_,27);
DYNX(W_,69) = DYNX(DP_,28);
DYNX(W_,70) = DYNX(DP_,29);
DYNX(W_,71) = DYNX(DP_,30);
DYNX(W_,72) = DYNX(DP_,31);
DYNX(W_,73) = DYNX(DP_,32);
DYNX(W_,74) = DYNX(DP_,33);
DYNX(W_,75) = DYNX(DP_,34);
DYNX(W_,76) = DYNX(DP_,35);
DYNX(W_,77) = DYNX(DP_,36);
DYNX(W_,78) = DYNX(DP_,37);
DYNX(W_,82) = DYNX(DP_,38);
DYNX(W_,84) = DYNX(DP_,38);
DYNX(W_,86) = DYNX(DP_,38);
DYNX(W_,88) = DYNX(DP_,38);
DYNX(W_,90) = DYNX(DP_,38);
DYNX(W_,92) = DYNX(DP_,38);
DYNX(W_,94) = DYNX(DP_,38);
DYNX(W_,96) = DYNX(DP_,38);
DYNX(W_,98) = DYNX(DP_,38);
DYNX(W_,100) = DYNX(DP_,38);
DYNX(W_,102) = DYNX(DP_,38);
DYNX(W_,104) = DYNX(DP_,38);
DYNX(W_,106) = DYNX(DP_,38);
DYNX(W_,109) = DYNX(W_,57)+DYNX(W_,81)-1;
DYNX(W_,110) = DYNX(W_,58)+DYNX(W_,82);
DYNX(W_,111) = DYNX(W_,57)+DYNX(W_,83);
DYNX(W_,112) = DYNX(W_,58)+DYNX(W_,84);
DYNX(W_,113) = DYNX(W_,59)+DYNX(W_,85);
DYNX(W_,114) = DYNX(W_,60)+DYNX(W_,86);
DYNX(W_,115) = DYNX(W_,61)+DYNX(W_,87);
DYNX(W_,116) = DYNX(W_,62)+DYNX(W_,88);
DYNX(W_,117) = DYNX(W_,63)+DYNX(W_,89);
DYNX(W_,118) = DYNX(W_,64)+DYNX(W_,90);
DYNX(W_,119) = DYNX(W_,65)+DYNX(W_,91);
DYNX(W_,120) = DYNX(W_,66)+DYNX(W_,92);
DYNX(W_,121) = DYNX(W_,67)+DYNX(W_,93);
DYNX(W_,122) = DYNX(W_,68)+DYNX(W_,94);
DYNX(W_,123) = DYNX(W_,69)+DYNX(W_,95);
DYNX(W_,124) = DYNX(W_,70)+DYNX(W_,96);
DYNX(W_,125) = DYNX(W_,71)+DYNX(W_,97);
DYNX(W_,126) = DYNX(W_,72)+DYNX(W_,98);
DYNX(W_,127) = DYNX(W_,73)+DYNX(W_,99);
DYNX(W_,128) = DYNX(W_,74)+DYNX(W_,100);
DYNX(W_,129) = DYNX(W_,75)+DYNX(W_,101);
DYNX(W_,130) = DYNX(W_,76)+DYNX(W_,102);
DYNX(W_,131) = DYNX(W_,77)+DYNX(W_,103);
DYNX(W_,132) = DYNX(W_,78)+DYNX(W_,104);
DYNX(W_,133) = 1.0+DYNX(W_,77)+DYNX(W_,105);
DYNX(W_,134) = DYNX(W_,78)+DYNX(W_,106);
DYNX(W_,159) =  -DYNX(DP_,0);
DYNX(W_,162) = DYNX(DP_,57);
DYNX(W_,163) = DYNX(DP_,57);
DYNX(W_,164) = DYNX(DP_,57);
DYNX(W_,165) = DYNX(DP_,57);
DYNX(W_,166) = DYNX(DP_,57);
DYNX(W_,167) = DYNX(DP_,57);
DYNX(W_,168) = DYNX(DP_,57);
DYNX(W_,169) = DYNX(DP_,57);
DYNX(W_,170) = DYNX(DP_,57);
DYNX(W_,171) = DYNX(DP_,57);
DYNX(W_,172) = DYNX(DP_,57);
DYNX(W_,173) = DYNX(DP_,57);
DYNX(W_,174) = DYNX(DP_,57);
DYNX(W_,138) = 0.0;
  {
    DYNX(W_,138) = 1.0;
  }
InitialBoundSection
{
  struct DymStruc0 dummy_DymStruc0;
  dummy_DymStruc0 = (PushModelContext(1,"Modelica.Blocks.Types.ExternalCombiTimeTable(\"LoadData\", \"C:/Users/Daniel Gerber/Desktop/LBL Sync Windows/ModelicaFiles/DC_Tool/Scripts/ModelicaMatDCToolTest.mat\", dataTable1.table, dataTable1.startTime, dataTable1.columns, Modelica.Blocks.Types.Smoothness.ContinuousDerivative, dataTable1.extrapolation, 0, 1)")
    Modelica_Blocks_Types_ExternalCombiTimeTable_M("LoadData", "C:/Users/Daniel Gerber/Desktop/LBL Sync Windows/ModelicaFiles/DC_Tool/Scripts/ModelicaMatDCToolTest.mat",
     RealTemporaryDense( (Real*)(0), 2, 0, 2), DYNX(W_,159), IntegerTemporaryDense( 
    &DYNX(DP_,43), 1, 13), 2, (Integer)(DYNX(DP_,56)), 0, 1));
  DYNX(W_,175) = dummy_DymStruc0.id_0member;
PopAllMarks();
}
DYNX(W_,177) = 0.0;
  {
    DYNX(W_,177) = (PushModelContext(1,"Modelica.Blocks.Sources.CombiTimeTable.readTableData(\ndataTable1.tableID, \nfalse, \ndataTable1.verboseRead)")
      Modelica_Blocks_Sources_CombiTimeTable_readTableData_M(DymStruc0_construct(
      (Integer)(DYNX(W_,175))), false, (Integer)(DYNX(DP_,42))));
  }
  DYNX(W_,160) = (PushModelContext(1,"Modelica.Blocks.Sources.CombiTimeTable.getTableTimeTmin(\ndataTable1.tableID, \ndataTable1.tableOnFileRead)")
    Modelica_Blocks_Sources_CombiTimeTable_getTableTimeTmin_M(DymStruc0_construct(
    (Integer)(DYNX(W_,175))), DYNX(W_,177)));
  DYNX(W_,161) = (PushModelContext(1,"Modelica.Blocks.Sources.CombiTimeTable.getTableTimeTmax(\ndataTable1.tableID, \ndataTable1.tableOnFileRead)")
    Modelica_Blocks_Sources_CombiTimeTable_getTableTimeTmax_M(DymStruc0_construct(
    (Integer)(DYNX(W_,175))), DYNX(W_,177)));
DYNX(W_,176) = (PushModelContext(1,"Modelica.Blocks.Sources.CombiTimeTable.getNextTimeEvent(\ndataTable1.tableID, \ntime, \ndataTable1.tableOnFileRead)")
  Modelica_Blocks_Sources_CombiTimeTable_getNextTimeEvent_M(DymStruc0_construct(
  (Integer)(DYNX(W_,175))), DYNTime, DYNX(W_,177)));
PopModelContext();
InitialSection2
DYNX(W_,5) = DYNX(DP_,10)*cos(DYNX(DP_,11));
DYNX(W_,6) = DYNX(DP_,10)*sin(DYNX(DP_,11));
DYNX(W_,43) = DYNX(DP_,15)*DYNX(DP_,3);
DYNX(W_,23) = fabs(DYNX(DP_,14));
DYNX(W_,31) = divmacro(DYNX(W_,5)*DYNX(W_,5)+DYNX(W_,6)*DYNX(W_,6),
  "source1.terminal.v[1]*source1.terminal.v[1]+source1.terminal.v[2]*source1.terminal.v[2]",
  powmacro(1.0000000000000002E-010+(DYNX(W_,5)*DYNX(W_,5)+DYNX(W_,6)*DYNX(W_,6))
  *(DYNX(W_,5)*DYNX(W_,5)+DYNX(W_,6)*DYNX(W_,6)),"1.0000000000000002E-010+(source1.terminal.v[1]*source1.terminal.v[1]+source1.terminal.v[2]*source1.terminal.v[2])*(source1.terminal.v[1]*source1.terminal.v[1]+source1.terminal.v[2]*source1.terminal.v[2])",
  0.25,"0.25"),"(1.0000000000000002E-010+(source1.terminal.v[1]*source1.terminal.v[1]+source1.terminal.v[2]*source1.terminal.v[2])*(source1.terminal.v[1]*source1.terminal.v[1]+source1.terminal.v[2]*source1.terminal.v[2]))^0.25");
DYNX(W_,46) = divmacro(DYNX(DP_,14),"aC1DC2.V2",DYNX(W_,31),"aC1DC2.v_n");
InitialBoundSection
{
  struct DymStruc0 dummy_DymStruc0;
  dummy_DymStruc0 = (PushModelContext(1,"Modelica.Blocks.Types.ExternalCombiTable1D(\"NoName\", \"NoName\", aC1DC2.tab.tab.table, aC1DC2.tab.tab.columns, Modelica.Blocks.Types.Smoothness.LinearSegments, 1, 1)")
    Modelica_Blocks_Types_ExternalCombiTable1D_M("NoName", "NoName", 
    RealTemporaryDense( &DYNX(W_,109), 2, 13, 2), IntegerTemporaryDense( 
    &DYNX(W_,135), 1, 1), 1, 1, 1));
  DYNX(W_,137) = dummy_DymStruc0.id_0member;
PopAllMarks();
}
InitialSection2
DYNX(W_,16) = DYNX(W_,164)+(PushModelContext(1,"Modelica.Blocks.Sources.CombiTimeTable.getTableValue(\ndataTable1.tableID, \n3, \ntime, \ndataTable1.nextTimeEvent, \ndataTable1.nextTimeEvent_.start, \ndataTable1.tableOnFileRead)")
  Modelica_Blocks_Sources_CombiTimeTable_getTableValue_M(DymStruc0_construct(
  (Integer)(DYNX(W_,175))), 3, DYNTime, DYNX(W_,176), DYNX(Aux_,0), DYNX(W_,177)));
PopModelContext();
DYNX(W_,29) = homotopy(divmacro(DYNX(W_,16),"load1.P",DYNX(DP_,14),"aC1DC2.V2"),
   0);
DYNX(W_,17) = (PushModelContext(1,"Modelica.Blocks.Sources.CombiTimeTable.getDerTableValue(\ndataTable1.tableID, \n3, \ntime, \ndataTable1.nextTimeEvent, \ndataTable1.nextTimeEvent_.start, \ndataTable1.tableOnFileRead, \n1.0)")
  Modelica_Blocks_Sources_CombiTimeTable_getDerTableValue_M(DymStruc0_construct(
  (Integer)(DYNX(W_,175))), 3, DYNTime, DYNX(W_,176), DYNX(Aux_,0), DYNX(W_,177),
   1.0));
PopModelContext();
DYNX(W_,30) = homotopy(divmacro(DYNX(W_,17),"der(load1.P)",DYNX(DP_,14),
  "aC1DC2.V2"), 0);
InitialSection2
Init_=false;InitializeData(2);Init_=true;
EndInitialSection

OutputSection

DynamicsSection

AcceptedSection1

AcceptedSection2
beginwhenBlock
whenModelica(GreaterEqualTimeMinor(PRE(DYNX(W_,176), 0), 0), 0) 
  DYNX(W_,176) = (PushModelContext(1,"Modelica.Blocks.Sources.CombiTimeTable.getNextTimeEvent(\ndataTable1.tableID, \ntime, \ndataTable1.tableOnFileRead)")
  Modelica_Blocks_Sources_CombiTimeTable_getNextTimeEvent_M(DymStruc0_construct(
  (Integer)(DYNX(W_,175))), DYNTime, DYNX(W_,177)));
endwhenModelica()
endwhenBlock
PopModelContext();
DYNX(DYNhelp,2) = (PushModelContext(1,"Modelica.Blocks.Sources.CombiTimeTable.getTableValue(\ndataTable1.tableID, \n3, \ntime, \ndataTable1.nextTimeEvent, \npre(dataTable1.nextTimeEvent), \ndataTable1.tableOnFileRead)")
  Modelica_Blocks_Sources_CombiTimeTable_getTableValue_M(DymStruc0_construct(
  (Integer)(DYNX(W_,175))), 3, DYNTime, DYNX(W_,176), PRE(DYNX(W_,176), 0), 
  DYNX(W_,177)));
PopModelContext();
DYNX(W_,16) = DYNX(W_,164)+DYNX(DYNhelp,2);
DYNX(W_,29) = divmacro(DYNX(W_,16),"load1.P",DYNX(DP_,14),"aC1DC2.V2");
DYNX(W_,47) = DYNX(DP_,14)*DYNX(W_,29);
DYNX(W_,53) = DYNX(DP_,14)*DYNX(W_,29);
{ /* Non-linear system of equations to solve. */
  /* Nonlinear system of equations number = 1. */
/* Introducing 20 common subexpressions and reusing 3 variables totally used in 11
   expressions */
/* Of the common subexpressions 23 are reals, 0 are integers, and 0
   are booleans. */
const char*const varnames_[]={"aC1DC2.terminal_n.i[1]", "aC1DC2.terminal_n.i[2]"};
const double nominal_[]={1, 1};
NonLinearSystemOfEquationsNH(Jacobian__, residue__, x__, 2, 0, 1, -1, 3, 
  DYNX(DYNhelp,3), 59, DYNX(did_->helpvari_vec,1), 24);
NonLinearSystemSave(DYNX(W_,47), 0);
NonLinearSystemSave(DYNX(W_,53), 1);
NonLinearSystemSave(DYNX(W_,29), 2);
SetInitVectorNH(x__, 1, DYNX(W_,24), Remember_(DYNX(W_,24), 0));
SetInitVectorNH(x__, 2, DYNX(W_,25), Remember_(DYNX(W_,25), 1));
Residues;
  DYNX(W_,55) = DYNX(W_,5)*DYNX(W_,24)+DYNX(W_,6)*DYNX(W_,25);
  DYNX(W_,139) = (PushModelContext(1,"Buildings.Utilities.Math.Functions.spliceFunction(aC1DC2.Preal_n, aC1DC2.Preal_p, aC1DC2.Preal_p, 0.1)")
    Buildings_Utilities_Math_Functions_spliceFunction(DYNX(W_,55), DYNX(W_,53), 
    DYNX(W_,53), 0.1));
  PopModelContext();
  DYNX(DYNhelp,62) = DYNX(W_,43)+1;
  DYNX(DYNhelp,63) = divmacro(1.0,"1.0",DYNX(DYNhelp,62),"aC1DC2.maxPower+1");
  DYNX(W_,44) = DYNX(DYNhelp,63)*DYNX(W_,139);
  DYNX(W_,41) = (PushModelContext(1,"Modelica.Blocks.Tables.CombiTable1D.getTableValue(\naC1DC2.tab.tab.tableID, \n1, \naC1DC2.percentPower, \naC1DC2.tab.tab.tableOnFileRead)")
    Modelica_Blocks_Tables_CombiTable1D_getTableValue_M(DymStruc0_construct(
    (Integer)(DYNX(W_,137))), 1, DYNX(W_,44), DYNX(W_,138)));
  PopModelContext();
  DYNX(W_,50) = DYNX(W_,55);
  DYNX(DYNhelp,64) = 1-DYNX(W_,41);
  DYNX(DYNhelp,65) = (PushModelContext(1,"Buildings.Utilities.Math.Functions.spliceFunction(aC1DC2.Pcomp_p[1], aC1DC2.Pcomp_n[1], aC1DC2.terminal_p.i[1], 0.1)")
    Buildings_Utilities_Math_Functions_spliceFunction(DYNX(W_,47), DYNX(W_,50), 
    DYNX(W_,29), 0.1));
  PopModelContext();
  DYNX(W_,34) = DYNX(DYNhelp,64)*DYNX(DYNhelp,65);
SetVector(residue__, 1, DYNX(W_,6)*DYNX(W_,24)-DYNX(W_,5)*DYNX(W_,25));
SetVector(residue__, 2, DYNX(W_,50)+DYNX(W_,47)-DYNX(W_,34));

Jacobian(Jacobian__)
MatrixZeros(Jacobian__);
DYNX(DYNhelp,66) = (PushModelContext(1,"Buildings.Utilities.Math.Functions.BaseClasses.der_spliceFunction(aC1DC2.Preal_n, aC1DC2.Preal_p, aC1DC2.Preal_p, 0.1, 1.0, 0.0, 0.0, 0.0)")
  Buildings_Utilities_Math_Functions_BaseClasses_derx_0spliceFunction(
  DYNX(W_,55), DYNX(W_,53), DYNX(W_,53), 0.1, 1.0, 0.0, 0.0, 0.0))*
  (PushModelContext(1,"Modelica.Blocks.Tables.CombiTable1D.getDerTableValue(\naC1DC2.tab.tab.tableID, \n1, \naC1DC2.percentPower, \naC1DC2.tab.tab.tableOnFileRead, \n1.0)")
  Modelica_Blocks_Tables_CombiTable1D_getDerTableValue_M(DymStruc0_construct(
  (Integer)(DYNX(W_,137))), 1, DYNX(W_,44), DYNX(W_,138), 1.0))*DYNX(DYNhelp,65);
PopModelContext();
DYNX(DYNhelp,67) = 1.0-DYNX(DYNhelp,64)*(PushModelContext(1,"Buildings.Utilities.Math.Functions.BaseClasses.der_spliceFunction(aC1DC2.Pcomp_p[1], aC1DC2.Pcomp_n[1], aC1DC2.terminal_p.i[1], 0.1, 0.0, 1.0, 0.0, 0.0)")
  Buildings_Utilities_Math_Functions_BaseClasses_derx_0spliceFunction(
  DYNX(W_,47), DYNX(W_,50), DYNX(W_,29), 0.1, 0.0, 1.0, 0.0, 0.0));
PopModelContext();
SetMatrixLeading(Jacobian__, 1, 1, 2, DYNX(W_,6));
SetMatrixLeading(Jacobian__, 1, 2, 2,  -DYNX(W_,5));
SetMatrixLeading(Jacobian__, 2, 1, 2, DYNX(DYNhelp,63)*DYNX(DYNhelp,66)*
  DYNX(W_,5)+DYNX(DYNhelp,67)*DYNX(W_,5));
SetMatrixLeading(Jacobian__, 2, 2, 2, DYNX(DYNhelp,63)*DYNX(DYNhelp,66)*
  DYNX(W_,6)+DYNX(DYNhelp,67)*DYNX(W_,6));

SolveNonLinearSystemOfEquationsNH(Jacobian__, residue__, x__, 1);
DYNX(W_,24) = GetVector(x__, 1);
DYNX(W_,25) = GetVector(x__, 2);
EndNonLinearSystemOfEquationsNH(residue__, x__, 1);
 /* End of Non-Linear Equation Block */ }



DYNX(W_,17) = (PushModelContext(1,"Modelica.Blocks.Sources.CombiTimeTable.getDerTableValue(\ndataTable1.tableID, \n3, \ntime, \ndataTable1.nextTimeEvent, \npre(dataTable1.nextTimeEvent), \ndataTable1.tableOnFileRead, \n1.0)")
  Modelica_Blocks_Sources_CombiTimeTable_getDerTableValue_M(DymStruc0_construct(
  (Integer)(DYNX(W_,175))), 3, DYNTime, DYNX(W_,176), PRE(DYNX(W_,176), 0), 
  DYNX(W_,177), 1.0));
PopModelContext();
DYNX(W_,30) = divmacro(DYNX(W_,17),"der(load1.P)",DYNX(DP_,14),"aC1DC2.V2");
DYNX(W_,49) = DYNX(DP_,14)*DYNX(W_,30);
DYNX(W_,54) = DYNX(DP_,14)*DYNX(W_,30);
BreakSectionFunctionCallNew(0);
BreakSectionFunctionEnd()
BreakSectionFunctionStart(1);
 /* Linear system of equations to solve. */
/* Introducing 13 common subexpressions and reusing 3 variables totally used in 15
   expressions */
/* Of the common subexpressions 16 are reals, 0 are integers, and 0
   are booleans. */
DYNX(DYNhelp,68) = (PushModelContext(1,"Modelica.Blocks.Tables.CombiTable1D.getDerTableValue(\naC1DC2.tab.tab.tableID, \n1, \naC1DC2.percentPower, \naC1DC2.tab.tab.tableOnFileRead, \n1.0)")
  Modelica_Blocks_Tables_CombiTable1D_getDerTableValue_M(DymStruc0_construct(
  (Integer)(DYNX(W_,137))), 1, DYNX(W_,44), DYNX(W_,138), 1.0));
PopModelContext();
DYNX(DYNhelp,69) = DYNX(DYNhelp,68)*DYNX(DYNhelp,65);
DYNX(DYNhelp,70) = (PushModelContext(1,"Buildings.Utilities.Math.Functions.BaseClasses.der_spliceFunction(aC1DC2.Preal_n, aC1DC2.Preal_p, aC1DC2.Preal_p, 0.1, 0.0, der(aC1DC2.Preal_p), der(aC1DC2.Preal_p), 0.0)")
  Buildings_Utilities_Math_Functions_BaseClasses_derx_0spliceFunction(
  DYNX(W_,55), DYNX(W_,53), DYNX(W_,53), 0.1, 0.0, DYNX(W_,54), DYNX(W_,54), 0.0));
PopModelContext();
DYNX(DYNhelp,71) = DYNX(W_,43)+1;
DYNX(DYNhelp,72) = divmacro(1.0,"1.0",DYNX(DYNhelp,71),"aC1DC2.maxPower+1");
DYNX(DYNhelp,73) = 1-DYNX(W_,41);
DYNX(DYNhelp,74) = (PushModelContext(1,"Buildings.Utilities.Math.Functions.BaseClasses.der_spliceFunction(aC1DC2.Pcomp_p[1], aC1DC2.Pcomp_n[1], aC1DC2.terminal_p.i[1], 0.1, der(aC1DC2.Pcomp_p[1]), 0.0, der(aC1DC2.terminal_p.i[1]), 0.0)")
  Buildings_Utilities_Math_Functions_BaseClasses_derx_0spliceFunction(
  DYNX(W_,47), DYNX(W_,50), DYNX(W_,29), 0.1, DYNX(W_,49), 0.0, DYNX(W_,30), 0.0));
PopModelContext();
/* Automatic tearing of linear system of 8 simultaneous equations
gave a linear system of 2 equations for numerical solution.*/
{
  const char*const varnames_[]={"aC1DC2.terminal_n.der(i[2])", "aC1DC2.terminal_n.der(i[1])"};
  const double nominal_[]={1, 1};
  DidLinearSystemOfEquations(J, b, y, 2, DYNX(DYNhelp,75), 24, DYNX(did_->helpvari_vec,25), 8);
  /* Jacobian depending on continuous variables */
  SetNeedFactor(J);
  if (NeedFactor(J)) {
    MatrixZeros(J);
    DYNX(DYNhelp,99) = (PushModelContext(1,"Buildings.Utilities.Math.Functions.BaseClasses.der_spliceFunction(aC1DC2.Preal_n, aC1DC2.Preal_p, aC1DC2.Preal_p, 0.1, 1.0, 0.0, 0.0, 0.0)")
      Buildings_Utilities_Math_Functions_BaseClasses_derx_0spliceFunction(
      DYNX(W_,55), DYNX(W_,53), DYNX(W_,53), 0.1, 1.0, 0.0, 0.0, 0.0));
    PopModelContext();
    DYNX(DYNhelp,100) = DYNX(DYNhelp,99)*DYNX(DYNhelp,69);
    DYNX(DYNhelp,101) = (PushModelContext(1,"Buildings.Utilities.Math.Functions.BaseClasses.der_spliceFunction(aC1DC2.Pcomp_p[1], aC1DC2.Pcomp_n[1], aC1DC2.terminal_p.i[1], 0.1, 0.0, 1.0, 0.0, 0.0)")
      Buildings_Utilities_Math_Functions_BaseClasses_derx_0spliceFunction(
      DYNX(W_,47), DYNX(W_,50), DYNX(W_,29), 0.1, 0.0, 1.0, 0.0, 0.0));
    PopModelContext();
    DYNX(DYNhelp,102) = 1.0-DYNX(DYNhelp,73)*DYNX(DYNhelp,101);
    SetMatrixLeading(J, 1, 1, 2,  -DYNX(W_,5));
    SetMatrixLeading(J, 1, 2, 2, DYNX(W_,6));
    SetMatrixLeading(J, 2, 1, 2, DYNX(DYNhelp,72)*DYNX(DYNhelp,100)*DYNX(W_,6)+
      DYNX(DYNhelp,102)*DYNX(W_,6));
    SetMatrixLeading(J, 2, 2, 2, DYNX(DYNhelp,72)*DYNX(DYNhelp,100)*DYNX(W_,5)+
      DYNX(DYNhelp,102)*DYNX(W_,5));
  }
  SetVector(b, 2,  -(DYNX(W_,49)+DYNX(DYNhelp,72)*DYNX(DYNhelp,69)*
    DYNX(DYNhelp,70)-DYNX(DYNhelp,73)*DYNX(DYNhelp,74)));
  SetVector(y, 1, RememberSimple_(DYNX(W_,27), 2));
  SetVector(y, 2, RememberSimple_(DYNX(W_,26), 3));
  SolveLinearSystemOfEquations(J, b, y, 1);
  DYNX(W_,27) = GetVector(y, 1);
  DYNX(W_,26) = GetVector(y, 2);
  EndStaticLinearSystemOfEquations(J);
}
DYNX(W_,56) = DYNX(W_,5)*DYNX(W_,26)+DYNX(W_,6)*DYNX(W_,27);
DYNX(W_,140) = (PushModelContext(1,"Buildings.Utilities.Math.Functions.BaseClasses.der_spliceFunction(aC1DC2.Preal_n, aC1DC2.Preal_p, aC1DC2.Preal_p, 0.1, der(aC1DC2.Preal_n), der(aC1DC2.Preal_p), der(aC1DC2.Preal_p), 0.0)")
  Buildings_Utilities_Math_Functions_BaseClasses_derx_0spliceFunction(
  DYNX(W_,55), DYNX(W_,53), DYNX(W_,53), 0.1, DYNX(W_,56), DYNX(W_,54), 
  DYNX(W_,54), 0.0));
PopModelContext();
DYNX(W_,45) = DYNX(DYNhelp,72)*DYNX(W_,140);
DYNX(W_,42) = (PushModelContext(1,"Modelica.Blocks.Tables.CombiTable1D.getDerTableValue(\naC1DC2.tab.tab.tableID, \n1, \naC1DC2.percentPower, \naC1DC2.tab.tab.tableOnFileRead, \nder(aC1DC2.percentPower))")
  Modelica_Blocks_Tables_CombiTable1D_getDerTableValue_M(DymStruc0_construct(
  (Integer)(DYNX(W_,137))), 1, DYNX(W_,44), DYNX(W_,138), DYNX(W_,45)));
PopModelContext();
DYNX(W_,52) = DYNX(W_,56);
DYNX(DYNhelp,103) = (PushModelContext(1,"Buildings.Utilities.Math.Functions.BaseClasses.der_spliceFunction(aC1DC2.Pcomp_p[1], aC1DC2.Pcomp_n[1], aC1DC2.terminal_p.i[1], 0.1, der(aC1DC2.Pcomp_p[1]), der(aC1DC2.Pcomp_n[1]), der(aC1DC2.terminal_p.i[1]), 0.0)")
  Buildings_Utilities_Math_Functions_BaseClasses_derx_0spliceFunction(
  DYNX(W_,47), DYNX(W_,50), DYNX(W_,29), 0.1, DYNX(W_,49), DYNX(W_,52), 
  DYNX(W_,30), 0.0));
PopModelContext();
DYNX(W_,35) = DYNX(DYNhelp,73)*DYNX(DYNhelp,103)-DYNX(W_,42)*DYNX(DYNhelp,65);
 /* End of Equation Block */ 

DYNX(W_,2) =  -(DYNX(W_,5)*DYNX(W_,24)+DYNX(W_,6)*DYNX(W_,25));
DYNX(W_,3) = DYNX(W_,5)*DYNX(W_,25)-DYNX(W_,6)*DYNX(W_,24);
if (NewParameters_) {
DYNX(DYNhelp,104) = atan2(DYNX(W_,6), DYNX(W_,5));
}
DYNX(DYNhelp,105) = atan2(DYNX(W_,25), DYNX(W_,24));
DYNX(W_,4) = DYNX(DYNhelp,104)-DYNX(DYNhelp,105);
DYNX(W_,7) = 6.283185307179586*DYNX(DP_,9)*DYNTime;
DYNX(W_,14) = DYNX(DP_,14)*DYNX(W_,29);
DYNX(W_,33) = divmacro(DYNX(W_,24)*DYNX(W_,24)+DYNX(W_,25)*DYNX(W_,25),
  "aC1DC2.terminal_n.i[1]*aC1DC2.terminal_n.i[1]+aC1DC2.terminal_n.i[2]*aC1DC2.terminal_n.i[2]",
  powmacro(1.0000000000000002E-010+(DYNX(W_,24)*DYNX(W_,24)+DYNX(W_,25)*
  DYNX(W_,25))*(DYNX(W_,24)*DYNX(W_,24)+DYNX(W_,25)*DYNX(W_,25)),
  "1.0000000000000002E-010+(aC1DC2.terminal_n.i[1]*aC1DC2.terminal_n.i[1]+aC1DC2.terminal_n.i[2]*aC1DC2.terminal_n.i[2])*(aC1DC2.terminal_n.i[1]*aC1DC2.terminal_n.i[1]+aC1DC2.terminal_n.i[2]*aC1DC2.terminal_n.i[2])",
  0.25,"0.25"),"(1.0000000000000002E-010+(aC1DC2.terminal_n.i[1]*aC1DC2.terminal_n.i[1]+aC1DC2.terminal_n.i[2]*aC1DC2.terminal_n.i[2])*(aC1DC2.terminal_n.i[1]*aC1DC2.terminal_n.i[1]+aC1DC2.terminal_n.i[2]*aC1DC2.terminal_n.i[2]))^0.25");
DYNX(W_,141) = DYNX(DP_,40)*(sqr(DYNX(W_,24))+sqr(DYNX(W_,25)));
DYNX(W_,142) =  -(DYNX(W_,5)*DYNX(W_,24)+DYNX(W_,6)*DYNX(W_,25));
DYNX(W_,143) = DYNX(W_,5)*DYNX(W_,24)+DYNX(W_,6)*DYNX(W_,25);
DYNX(DYNhelp,106) = (PushModelContext(1,"Modelica.Blocks.Sources.CombiTimeTable.getTableValue(\ndataTable1.tableID, \n1, \ntime, \ndataTable1.nextTimeEvent, \npre(dataTable1.nextTimeEvent), \ndataTable1.tableOnFileRead)")
  Modelica_Blocks_Sources_CombiTimeTable_getTableValue_M(DymStruc0_construct(
  (Integer)(DYNX(W_,175))), 1, DYNTime, DYNX(W_,176), PRE(DYNX(W_,176), 0), 
  DYNX(W_,177)));
PopModelContext();
DYNX(W_,145) = DYNX(W_,162)+DYNX(DYNhelp,106);
DYNX(DYNhelp,107) = (PushModelContext(1,"Modelica.Blocks.Sources.CombiTimeTable.getTableValue(\ndataTable1.tableID, \n2, \ntime, \ndataTable1.nextTimeEvent, \npre(dataTable1.nextTimeEvent), \ndataTable1.tableOnFileRead)")
  Modelica_Blocks_Sources_CombiTimeTable_getTableValue_M(DymStruc0_construct(
  (Integer)(DYNX(W_,175))), 2, DYNTime, DYNX(W_,176), PRE(DYNX(W_,176), 0), 
  DYNX(W_,177)));
PopModelContext();
DYNX(W_,146) = DYNX(W_,163)+DYNX(DYNhelp,107);
DYNX(DYNhelp,108) = (PushModelContext(1,"Modelica.Blocks.Sources.CombiTimeTable.getTableValue(\ndataTable1.tableID, \n4, \ntime, \ndataTable1.nextTimeEvent, \npre(dataTable1.nextTimeEvent), \ndataTable1.tableOnFileRead)")
  Modelica_Blocks_Sources_CombiTimeTable_getTableValue_M(DymStruc0_construct(
  (Integer)(DYNX(W_,175))), 4, DYNTime, DYNX(W_,176), PRE(DYNX(W_,176), 0), 
  DYNX(W_,177)));
PopModelContext();
DYNX(W_,147) = DYNX(W_,165)+DYNX(DYNhelp,108);
DYNX(DYNhelp,109) = (PushModelContext(1,"Modelica.Blocks.Sources.CombiTimeTable.getTableValue(\ndataTable1.tableID, \n5, \ntime, \ndataTable1.nextTimeEvent, \npre(dataTable1.nextTimeEvent), \ndataTable1.tableOnFileRead)")
  Modelica_Blocks_Sources_CombiTimeTable_getTableValue_M(DymStruc0_construct(
  (Integer)(DYNX(W_,175))), 5, DYNTime, DYNX(W_,176), PRE(DYNX(W_,176), 0), 
  DYNX(W_,177)));
PopModelContext();
DYNX(W_,148) = DYNX(W_,166)+DYNX(DYNhelp,109);
DYNX(DYNhelp,110) = (PushModelContext(1,"Modelica.Blocks.Sources.CombiTimeTable.getTableValue(\ndataTable1.tableID, \n6, \ntime, \ndataTable1.nextTimeEvent, \npre(dataTable1.nextTimeEvent), \ndataTable1.tableOnFileRead)")
  Modelica_Blocks_Sources_CombiTimeTable_getTableValue_M(DymStruc0_construct(
  (Integer)(DYNX(W_,175))), 6, DYNTime, DYNX(W_,176), PRE(DYNX(W_,176), 0), 
  DYNX(W_,177)));
PopModelContext();
DYNX(W_,149) = DYNX(W_,167)+DYNX(DYNhelp,110);
DYNX(DYNhelp,111) = (PushModelContext(1,"Modelica.Blocks.Sources.CombiTimeTable.getTableValue(\ndataTable1.tableID, \n7, \ntime, \ndataTable1.nextTimeEvent, \npre(dataTable1.nextTimeEvent), \ndataTable1.tableOnFileRead)")
  Modelica_Blocks_Sources_CombiTimeTable_getTableValue_M(DymStruc0_construct(
  (Integer)(DYNX(W_,175))), 7, DYNTime, DYNX(W_,176), PRE(DYNX(W_,176), 0), 
  DYNX(W_,177)));
PopModelContext();
DYNX(W_,150) = DYNX(W_,168)+DYNX(DYNhelp,111);
DYNX(DYNhelp,112) = (PushModelContext(1,"Modelica.Blocks.Sources.CombiTimeTable.getTableValue(\ndataTable1.tableID, \n8, \ntime, \ndataTable1.nextTimeEvent, \npre(dataTable1.nextTimeEvent), \ndataTable1.tableOnFileRead)")
  Modelica_Blocks_Sources_CombiTimeTable_getTableValue_M(DymStruc0_construct(
  (Integer)(DYNX(W_,175))), 8, DYNTime, DYNX(W_,176), PRE(DYNX(W_,176), 0), 
  DYNX(W_,177)));
PopModelContext();
DYNX(W_,151) = DYNX(W_,169)+DYNX(DYNhelp,112);
DYNX(DYNhelp,113) = (PushModelContext(1,"Modelica.Blocks.Sources.CombiTimeTable.getTableValue(\ndataTable1.tableID, \n9, \ntime, \ndataTable1.nextTimeEvent, \npre(dataTable1.nextTimeEvent), \ndataTable1.tableOnFileRead)")
  Modelica_Blocks_Sources_CombiTimeTable_getTableValue_M(DymStruc0_construct(
  (Integer)(DYNX(W_,175))), 9, DYNTime, DYNX(W_,176), PRE(DYNX(W_,176), 0), 
  DYNX(W_,177)));
PopModelContext();
DYNX(W_,152) = DYNX(W_,170)+DYNX(DYNhelp,113);
DYNX(DYNhelp,114) = (PushModelContext(1,"Modelica.Blocks.Sources.CombiTimeTable.getTableValue(\ndataTable1.tableID, \n10, \ntime, \ndataTable1.nextTimeEvent, \npre(dataTable1.nextTimeEvent), \ndataTable1.tableOnFileRead)")
  Modelica_Blocks_Sources_CombiTimeTable_getTableValue_M(DymStruc0_construct(
  (Integer)(DYNX(W_,175))), 10, DYNTime, DYNX(W_,176), PRE(DYNX(W_,176), 0), 
  DYNX(W_,177)));
PopModelContext();
DYNX(W_,153) = DYNX(W_,171)+DYNX(DYNhelp,114);
DYNX(DYNhelp,115) = (PushModelContext(1,"Modelica.Blocks.Sources.CombiTimeTable.getTableValue(\ndataTable1.tableID, \n11, \ntime, \ndataTable1.nextTimeEvent, \npre(dataTable1.nextTimeEvent), \ndataTable1.tableOnFileRead)")
  Modelica_Blocks_Sources_CombiTimeTable_getTableValue_M(DymStruc0_construct(
  (Integer)(DYNX(W_,175))), 11, DYNTime, DYNX(W_,176), PRE(DYNX(W_,176), 0), 
  DYNX(W_,177)));
PopModelContext();
DYNX(W_,154) = DYNX(W_,172)+DYNX(DYNhelp,115);
DYNX(DYNhelp,116) = (PushModelContext(1,"Modelica.Blocks.Sources.CombiTimeTable.getTableValue(\ndataTable1.tableID, \n12, \ntime, \ndataTable1.nextTimeEvent, \npre(dataTable1.nextTimeEvent), \ndataTable1.tableOnFileRead)")
  Modelica_Blocks_Sources_CombiTimeTable_getTableValue_M(DymStruc0_construct(
  (Integer)(DYNX(W_,175))), 12, DYNTime, DYNX(W_,176), PRE(DYNX(W_,176), 0), 
  DYNX(W_,177)));
PopModelContext();
DYNX(W_,155) = DYNX(W_,173)+DYNX(DYNhelp,116);
DYNX(DYNhelp,117) = (PushModelContext(1,"Modelica.Blocks.Sources.CombiTimeTable.getTableValue(\ndataTable1.tableID, \n13, \ntime, \ndataTable1.nextTimeEvent, \npre(dataTable1.nextTimeEvent), \ndataTable1.tableOnFileRead)")
  Modelica_Blocks_Sources_CombiTimeTable_getTableValue_M(DymStruc0_construct(
  (Integer)(DYNX(W_,175))), 13, DYNTime, DYNX(W_,176), PRE(DYNX(W_,176), 0), 
  DYNX(W_,177)));
PopModelContext();
DYNX(W_,156) = DYNX(W_,174)+DYNX(DYNhelp,117);
DYNX(W_,32) = DYNX(W_,30);

DefaultSection
InitializeData(1)
EndTranslatedEquations

#include <dsblock6.c>

PreNonAliasNew(0)
StartNonAlias(0)
DeclareParameter("startTime", "exact second of the year to start the week long simulation [s]",\
 0, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("calibrateMode", "If true, converters are max efficiency of efficiency curve [:#(type=Boolean)]",\
 1, true, 0.0,0.0,0.0,0,562)
DeclareParameter("solarCapacity", "max power of solar in kW", 2, 1, 0.0,0.0,0.0,\
0,560)
DeclareParameter("converterOversizeRatio", "how much bigger the converters are sized compared to their peak power [1]",\
 3, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("batteryCapacity", "total capacity of battery in W-sec [J]", 4,\
 0, 0.0,0.0,0.0,0,560)
DeclareParameter("batteryChargingPower", "battery charging rate in W [W]", 5, 16500,\
 0.0,0.0,0.0,0,560)
DeclareParameter("battChgEff", "[1]", 6, 0.9, 0.0,1E+100,0.0,0,560)
DeclareParameter("battDisChgEff", "[1]", 7, 0.9, 0.0,1E+100,0.0,0,560)
DeclareParameter("partitionedMPPT", "if true, use microinverters and power optimizers instead of inverters and mppt cc modules [:#(type=Boolean)]",\
 8, false, 0.0,0.0,0.0,0,562)
DeclareVariable("source1.potentialReference", "Serve as potential root for the reference angle theta [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("source1.definiteReference", "Serve as definite root for the reference angle theta [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("source1.S[1]", "Complex power S[1] = P, S[2]= Q [W]", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("source1.S[2]", "Complex power S[1] = P, S[2]= Q [W]", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("source1.phi", "Phase shift with respect to reference angle [rad|deg]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("source1.terminal.v[1]", "Voltage vector [V]", 0.0, 0.0,0.0,0.0,\
0,521)
DeclareVariable("source1.terminal.v[2]", "Voltage vector [V]", 0.0, 0.0,0.0,0.0,\
0,521)
DeclareAlias2("source1.terminal.i[1]", "Current vector [A]", "aC1DC2.terminal_n.i[1]", -1,\
 5, 24, 132)
DeclareAlias2("source1.terminal.i[2]", "Current vector [A]", "aC1DC2.terminal_n.i[2]", -1,\
 5, 25, 132)
DeclareVariable("source1.terminal.theta[1]", "Optional vector of phase angles [rad|deg]",\
 0.0, 0.0,0.0,0.0,0,520)
DeclareParameter("source1.f", "Frequency of the source [Hz]", 9, 60, 0.0,0.0,0.0,\
0,560)
DeclareParameter("source1.V", "RMS voltage of the source [V]", 10, 120, 0.0,0.0,\
0.0,0,560)
DeclareParameter("source1.phiSou", "Phase shift of the source [rad|deg]", 11, 0,\
 0.0,0.0,0.0,0,560)
DeclareVariable("source1.thetaRel", "Absolute angle of rotating system as offset to thetaRef [rad|deg]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("load1.linearized", "If true, the load model is linearized [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("load1.mode", "Type of load model (e.g., steady state, dynamic, prescribed power consumption, etc.) [:#(type=Buildings.Electrical.Types.Load)]",\
 3, 1.0,4.0,0.0,0,517)
DeclareParameter("load1.P_nominal", "Nominal power (negative if consumed, positive if generated). Used if mode <> Buildings.Electrical.Types.Load.VariableZ_P_input [W]",\
 12, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("load1.V_nominal", "Nominal voltage (V_nominal >= 0) [V]", 48, \
0.0,1E+100,0.0,0,513)
DeclareVariable("load1.initMode", "Initialization mode for homotopy operator [:#(type=Buildings.Electrical.Types.InitMode)]",\
 1, 1.0,2.0,0.0,0,517)
DeclareAlias2("load1.v[1]", "Voltage vector [V]", "aC1DC2.V2", 1, 7, 14, 0)
DeclareVariable("load1.v[2]", "Voltage vector [V]", 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("load1.i[1]", "Current vector [A]", "aC1DC2.terminal_p.i[1]", -1, 5,\
 29, 0)
DeclareAlias2("load1.i[2]", "Current vector [A]", "aC1DC2.terminal_p.i[1]", 1, 5,\
 29, 0)
DeclareVariable("load1.S[1]", "Phase powers [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("load1.S[2]", "Phase powers [W]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("load1.P", "Power of the load (negative if consumed, positive if fed into the electrical grid) [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("load1.der(P)", "der(Power of the load (negative if consumed, positive if fed into the electrical grid)) [W/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("load1.Pow", "Power consumed [W]", "load1.P", 1, 5, 16, 0)
DeclareAlias2("load1.terminal.v[1]", "Voltage vector [V]", "aC1DC2.V2", 1, 7, 14,\
 4)
DeclareVariable("load1.terminal.v[2]", "Voltage vector [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("load1.terminal.i[1]", "Current vector [A]", "aC1DC2.terminal_p.i[1]", -1,\
 5, 29, 132)
DeclareAlias2("load1.terminal.i[2]", "Current vector [A]", "aC1DC2.terminal_p.i[1]", 1,\
 5, 29, 132)
DeclareVariable("load1.y_internal", "Hidden value of the input load for the conditional connector",\
 1, 0.0,0.0,0.0,0,2561)
DeclareAlias2("load1.P_internal", "Hidden value of the input power for the conditional connector [W]",\
 "load1.P", 1, 5, 16, 1024)
DeclareVariable("load1.load", "Internal representation of control signal, used to avoid singularity [1]",\
 1, 1E-010,1.0,0.0,0,2561)
DeclareVariable("load1.eps", "Small number used to avoid a singularity if the power is zero [1]",\
 1E-010, 0.0,0.0,0.0,0,2561)
DeclareVariable("load1.oneEps", "Small number used to avoid a singularity if the power is zero [1]",\
 0.9999999999, 0.0,0.0,0.0,0,2561)
DeclareVariable("load1.absDV", "Absolute value of the voltage difference between the two conductors (used by the linearized model) [V]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("aC1DC2.terminal_n.v[1]", "Voltage vector [V]", "source1.terminal.v[1]", 1,\
 5, 5, 4)
DeclareAlias2("aC1DC2.terminal_n.v[2]", "Voltage vector [V]", "source1.terminal.v[2]", 1,\
 5, 6, 4)
DeclareVariable("aC1DC2.terminal_n.i[1]", "Current vector [A]", 0, 0.0,0.0,0.0,0,840)
DeclareVariable("aC1DC2.terminal_n.i[2]", "Current vector [A]", 0, 0.0,0.0,0.0,0,840)
DeclareVariable("aC1DC2.terminal_n.der(i[1])", "der(Current vector) [A/s]", 0.0,\
 0.0,0.0,0.0,0,520)
DeclareVariable("aC1DC2.terminal_n.der(i[2])", "der(Current vector) [A/s]", 0.0,\
 0.0,0.0,0.0,0,520)
DeclareAlias2("aC1DC2.terminal_n.theta[1]", "Optional vector of phase angles [rad|deg]",\
 "source1.terminal.theta[1]", 1, 5, 7, 4)
DeclareAlias2("aC1DC2.terminal_p.v[1]", "Voltage vector [V]", "aC1DC2.V2", 1, 7,\
 14, 4)
DeclareVariable("aC1DC2.terminal_p.v[2]", "Voltage vector [V]", 0.0, 0.0,0.0,0.0,\
0,521)
DeclareVariable("aC1DC2.terminal_p.i[1]", "Current vector [A]", 0, 0.0,0.0,0.0,0,776)
DeclareAlias2("aC1DC2.terminal_p.i[2]", "Current vector [A]", "aC1DC2.terminal_p.i[1]", -1,\
 5, 29, 132)
DeclareVariable("aC1DC2.terminal_p.der(i[1])", "der(Current vector) [A/s]", 0.0,\
 0.0,0.0,0.0,0,520)
DeclareAlias2("aC1DC2.terminal_p.der(i[2])", "der(Current vector) [A/s]", \
"aC1DC2.terminal_p.der(i[1])", -1, 5, 30, 4)
DeclareAlias2("aC1DC2.v_p", "Voltage drop between the two positive pins [V]", \
"aC1DC2.V2", 1, 7, 14, 0)
DeclareVariable("aC1DC2.v_n", "Voltage drop between the two negative pins [V]", \
0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("aC1DC2.i_p", "Current flowing through the positive pins [A]", \
"aC1DC2.terminal_p.i[1]", 1, 5, 29, 0)
DeclareVariable("aC1DC2.der(i_p)", "der(Current flowing through the positive pins) [A/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("aC1DC2.i_n", "Current flowing through the negative pins [A]", \
0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("aC1DC2.lossPower", "Power lost [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("aC1DC2.der(lossPower)", "der(Power lost) [W/s]", 0.0, 0.0,0.0,\
0.0,0,512)
DeclareParameter("aC1DC2.V1", "Voltage on side 1 of the transformer (primary side) [V]",\
 13, 120, 0.0,0.0,0.0,0,560)
DeclareParameter("aC1DC2.V2", "Voltage on side 2 of the transformer (secondary side) [V]",\
 14, 48, 0.0,0.0,0.0,0,560)
DeclareParameter("aC1DC2.peakPower", "Maximum power expected through converter [W]",\
 15, 0, 0.0,1E+100,0.0,0,560)
DeclareParameter("aC1DC2.efficiencyTable[1, 1]", "Pout/MaxP vs Eff table (Pout, Eff)",\
 16, 0.1, 0.0,0.0,0.0,0,560)
DeclareParameter("aC1DC2.efficiencyTable[1, 2]", "Pout/MaxP vs Eff table (Pout, Eff)",\
 17, 1.0, 0.0,0.0,0.0,0,560)
DeclareParameter("aC1DC2.efficiencyTable[2, 1]", "Pout/MaxP vs Eff table (Pout, Eff)",\
 18, 0.2, 0.0,0.0,0.0,0,560)
DeclareParameter("aC1DC2.efficiencyTable[2, 2]", "Pout/MaxP vs Eff table (Pout, Eff)",\
 19, 1.0, 0.0,0.0,0.0,0,560)
DeclareParameter("aC1DC2.efficiencyTable[3, 1]", "Pout/MaxP vs Eff table (Pout, Eff)",\
 20, 0.3, 0.0,0.0,0.0,0,560)
DeclareParameter("aC1DC2.efficiencyTable[3, 2]", "Pout/MaxP vs Eff table (Pout, Eff)",\
 21, 1.0, 0.0,0.0,0.0,0,560)
DeclareParameter("aC1DC2.efficiencyTable[4, 1]", "Pout/MaxP vs Eff table (Pout, Eff)",\
 22, 0.4, 0.0,0.0,0.0,0,560)
DeclareParameter("aC1DC2.efficiencyTable[4, 2]", "Pout/MaxP vs Eff table (Pout, Eff)",\
 23, 1.0, 0.0,0.0,0.0,0,560)
DeclareParameter("aC1DC2.efficiencyTable[5, 1]", "Pout/MaxP vs Eff table (Pout, Eff)",\
 24, 0.5, 0.0,0.0,0.0,0,560)
DeclareParameter("aC1DC2.efficiencyTable[5, 2]", "Pout/MaxP vs Eff table (Pout, Eff)",\
 25, 1.0, 0.0,0.0,0.0,0,560)
DeclareParameter("aC1DC2.efficiencyTable[6, 1]", "Pout/MaxP vs Eff table (Pout, Eff)",\
 26, 0.6, 0.0,0.0,0.0,0,560)
DeclareParameter("aC1DC2.efficiencyTable[6, 2]", "Pout/MaxP vs Eff table (Pout, Eff)",\
 27, 1.0, 0.0,0.0,0.0,0,560)
DeclareParameter("aC1DC2.efficiencyTable[7, 1]", "Pout/MaxP vs Eff table (Pout, Eff)",\
 28, 0.7, 0.0,0.0,0.0,0,560)
DeclareParameter("aC1DC2.efficiencyTable[7, 2]", "Pout/MaxP vs Eff table (Pout, Eff)",\
 29, 1.0, 0.0,0.0,0.0,0,560)
DeclareParameter("aC1DC2.efficiencyTable[8, 1]", "Pout/MaxP vs Eff table (Pout, Eff)",\
 30, 0.75, 0.0,0.0,0.0,0,560)
DeclareParameter("aC1DC2.efficiencyTable[8, 2]", "Pout/MaxP vs Eff table (Pout, Eff)",\
 31, 1.0, 0.0,0.0,0.0,0,560)
DeclareParameter("aC1DC2.efficiencyTable[9, 1]", "Pout/MaxP vs Eff table (Pout, Eff)",\
 32, 0.8, 0.0,0.0,0.0,0,560)
DeclareParameter("aC1DC2.efficiencyTable[9, 2]", "Pout/MaxP vs Eff table (Pout, Eff)",\
 33, 1.0, 0.0,0.0,0.0,0,560)
DeclareParameter("aC1DC2.efficiencyTable[10, 1]", "Pout/MaxP vs Eff table (Pout, Eff)",\
 34, 0.9, 0.0,0.0,0.0,0,560)
DeclareParameter("aC1DC2.efficiencyTable[10, 2]", "Pout/MaxP vs Eff table (Pout, Eff)",\
 35, 1.0, 0.0,0.0,0.0,0,560)
DeclareParameter("aC1DC2.efficiencyTable[11, 1]", "Pout/MaxP vs Eff table (Pout, Eff)",\
 36, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("aC1DC2.efficiencyTable[11, 2]", "Pout/MaxP vs Eff table (Pout, Eff)",\
 37, 1, 0.0,0.0,0.0,0,560)
DeclareVariable("aC1DC2.percentMax", "If > 0, then will use efficiency data cooresponding to percentMax percent max power",\
 -1.0, -1E+100,1.0,0.0,0,513)
DeclareVariable("aC1DC2.fixV1", "Primary side voltage is fixed at a value of V1 [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("aC1DC2.fixV2", "Secondary side voltage is fixed at a value of V2 [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("aC1DC2.ground_1", "Connect primary side of converter to ground [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("aC1DC2.ground_2", "Connect secondary side of converter to ground [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("aC1DC2.eta", "Converter efficiency for power flow equations [1]",\
 0.0, 0.0,1.0,0.0,0,512)
DeclareVariable("aC1DC2.der(eta)", "der(Converter efficiency for power flow equations) [s-1]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("aC1DC2.maxPower", "Maximum power converter is rated to output [W]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("aC1DC2.percentPower", "Output power percent of maxPower", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("aC1DC2.der(percentPower)", "der(Output power percent of maxPower)",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("aC1DC2.conversionFactor", "Ratio of V secondary / V primary [1]",\
 1E-015, 1E-015,1E+100,0.0,0,513)
DeclareVariable("aC1DC2.Pcomp_p[1]", "Complex power transmitted at pin p [W]", \
0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("aC1DC2.Pcomp_p[2]", "Complex power transmitted at pin p [W]", \
0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("aC1DC2.der(Pcomp_p[1])", "der(Complex power transmitted at pin p) [W/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("aC1DC2.Pcomp_n[1]", "Complex power transmitted at pin n [W]", \
0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("aC1DC2.Pcomp_n[2]", "Complex power transmitted at pin n [W]", \
0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("aC1DC2.der(Pcomp_n[1])", "der(Complex power transmitted at pin n) [W/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("aC1DC2.Preal_p", "Real power transmitted at pin p [W]", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("aC1DC2.der(Preal_p)", "der(Real power transmitted at pin p) [W/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("aC1DC2.Preal_n", "Real power transmitted at pin n [W]", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("aC1DC2.der(Preal_n)", "der(Real power transmitted at pin n) [W/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("aC1DC2.tab.u", "Connector of Real input signal", "aC1DC2.percentPower", 1,\
 5, 44, 0)
DeclareAlias2("aC1DC2.tab.y", "Connector of Real output signal [1]", \
"aC1DC2.eta", 1, 5, 41, 0)
DeclareVariable("aC1DC2.tab.table[1, 1]", "Table matrix ( e.g., table=[u1, y1; u2, y2; u3, y3])",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("aC1DC2.tab.table[1, 2]", "Table matrix ( e.g., table=[u1, y1; u2, y2; u3, y3])",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("aC1DC2.tab.table[2, 1]", "Table matrix ( e.g., table=[u1, y1; u2, y2; u3, y3])",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("aC1DC2.tab.table[2, 2]", "Table matrix ( e.g., table=[u1, y1; u2, y2; u3, y3])",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("aC1DC2.tab.table[3, 1]", "Table matrix ( e.g., table=[u1, y1; u2, y2; u3, y3])",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("aC1DC2.tab.table[3, 2]", "Table matrix ( e.g., table=[u1, y1; u2, y2; u3, y3])",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("aC1DC2.tab.table[4, 1]", "Table matrix ( e.g., table=[u1, y1; u2, y2; u3, y3])",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("aC1DC2.tab.table[4, 2]", "Table matrix ( e.g., table=[u1, y1; u2, y2; u3, y3])",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("aC1DC2.tab.table[5, 1]", "Table matrix ( e.g., table=[u1, y1; u2, y2; u3, y3])",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("aC1DC2.tab.table[5, 2]", "Table matrix ( e.g., table=[u1, y1; u2, y2; u3, y3])",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("aC1DC2.tab.table[6, 1]", "Table matrix ( e.g., table=[u1, y1; u2, y2; u3, y3])",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("aC1DC2.tab.table[6, 2]", "Table matrix ( e.g., table=[u1, y1; u2, y2; u3, y3])",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("aC1DC2.tab.table[7, 1]", "Table matrix ( e.g., table=[u1, y1; u2, y2; u3, y3])",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("aC1DC2.tab.table[7, 2]", "Table matrix ( e.g., table=[u1, y1; u2, y2; u3, y3])",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("aC1DC2.tab.table[8, 1]", "Table matrix ( e.g., table=[u1, y1; u2, y2; u3, y3])",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("aC1DC2.tab.table[8, 2]", "Table matrix ( e.g., table=[u1, y1; u2, y2; u3, y3])",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("aC1DC2.tab.table[9, 1]", "Table matrix ( e.g., table=[u1, y1; u2, y2; u3, y3])",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("aC1DC2.tab.table[9, 2]", "Table matrix ( e.g., table=[u1, y1; u2, y2; u3, y3])",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("aC1DC2.tab.table[10, 1]", "Table matrix ( e.g., table=[u1, y1; u2, y2; u3, y3])",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("aC1DC2.tab.table[10, 2]", "Table matrix ( e.g., table=[u1, y1; u2, y2; u3, y3])",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("aC1DC2.tab.table[11, 1]", "Table matrix ( e.g., table=[u1, y1; u2, y2; u3, y3])",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("aC1DC2.tab.table[11, 2]", "Table matrix ( e.g., table=[u1, y1; u2, y2; u3, y3])",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("aC1DC2.tab.offset", "Offset of output signal", 38, 0, 0.0,0.0,\
0.0,0,560)
DeclareVariable("aC1DC2.tab.constantExtrapolation", "If true, then y=y1 for u<u1, and y=yMax for u>uMax [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("aC1DC2.tab.nCol", "Number of columns [:#(type=Integer)]", 13, \
0.0,0.0,0.0,0,2565)
DeclareVariable("aC1DC2.tab.offsetVector[1, 1]", "Vector to take offset of output signal into account",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("aC1DC2.tab.offsetVector[1, 2]", "Vector to take offset of output signal into account",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("aC1DC2.tab.offsetVector[2, 1]", "Vector to take offset of output signal into account",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("aC1DC2.tab.offsetVector[2, 2]", "Vector to take offset of output signal into account",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("aC1DC2.tab.offsetVector[3, 1]", "Vector to take offset of output signal into account",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("aC1DC2.tab.offsetVector[3, 2]", "Vector to take offset of output signal into account",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("aC1DC2.tab.offsetVector[4, 1]", "Vector to take offset of output signal into account",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("aC1DC2.tab.offsetVector[4, 2]", "Vector to take offset of output signal into account",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("aC1DC2.tab.offsetVector[5, 1]", "Vector to take offset of output signal into account",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("aC1DC2.tab.offsetVector[5, 2]", "Vector to take offset of output signal into account",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("aC1DC2.tab.offsetVector[6, 1]", "Vector to take offset of output signal into account",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("aC1DC2.tab.offsetVector[6, 2]", "Vector to take offset of output signal into account",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("aC1DC2.tab.offsetVector[7, 1]", "Vector to take offset of output signal into account",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("aC1DC2.tab.offsetVector[7, 2]", "Vector to take offset of output signal into account",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("aC1DC2.tab.offsetVector[8, 1]", "Vector to take offset of output signal into account",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("aC1DC2.tab.offsetVector[8, 2]", "Vector to take offset of output signal into account",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("aC1DC2.tab.offsetVector[9, 1]", "Vector to take offset of output signal into account",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("aC1DC2.tab.offsetVector[9, 2]", "Vector to take offset of output signal into account",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("aC1DC2.tab.offsetVector[10, 1]", "Vector to take offset of output signal into account",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("aC1DC2.tab.offsetVector[10, 2]", "Vector to take offset of output signal into account",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("aC1DC2.tab.offsetVector[11, 1]", "Vector to take offset of output signal into account",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("aC1DC2.tab.offsetVector[11, 2]", "Vector to take offset of output signal into account",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("aC1DC2.tab.offsetVector[12, 1]", "Vector to take offset of output signal into account",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("aC1DC2.tab.offsetVector[12, 2]", "Vector to take offset of output signal into account",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("aC1DC2.tab.offsetVector[13, 1]", "Vector to take offset of output signal into account",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("aC1DC2.tab.offsetVector[13, 2]", "Vector to take offset of output signal into account",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("aC1DC2.tab.tab.n", "Number of inputs (= number of outputs) [:#(type=Integer)]",\
 1, 0.0,0.0,0.0,0,2565)
DeclareAlias2("aC1DC2.tab.tab.u[1]", "Connector of Real input signals", \
"aC1DC2.percentPower", 1, 5, 44, 1024)
DeclareAlias2("aC1DC2.tab.tab.y[1]", "Connector of Real output signals [1]", \
"aC1DC2.eta", 1, 5, 41, 1024)
DeclareVariable("aC1DC2.tab.tab.tableOnFile", "= true, if table is defined on file or in function usertab [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("aC1DC2.tab.tab.table[1, 1]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("aC1DC2.tab.tab.table[1, 2]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("aC1DC2.tab.tab.table[2, 1]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("aC1DC2.tab.tab.table[2, 2]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("aC1DC2.tab.tab.table[3, 1]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("aC1DC2.tab.tab.table[3, 2]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("aC1DC2.tab.tab.table[4, 1]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("aC1DC2.tab.tab.table[4, 2]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("aC1DC2.tab.tab.table[5, 1]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("aC1DC2.tab.tab.table[5, 2]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("aC1DC2.tab.tab.table[6, 1]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("aC1DC2.tab.tab.table[6, 2]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("aC1DC2.tab.tab.table[7, 1]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("aC1DC2.tab.tab.table[7, 2]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("aC1DC2.tab.tab.table[8, 1]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("aC1DC2.tab.tab.table[8, 2]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("aC1DC2.tab.tab.table[9, 1]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("aC1DC2.tab.tab.table[9, 2]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("aC1DC2.tab.tab.table[10, 1]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("aC1DC2.tab.tab.table[10, 2]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("aC1DC2.tab.tab.table[11, 1]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("aC1DC2.tab.tab.table[11, 2]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("aC1DC2.tab.tab.table[12, 1]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("aC1DC2.tab.tab.table[12, 2]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("aC1DC2.tab.tab.table[13, 1]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("aC1DC2.tab.tab.table[13, 2]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareParameter("aC1DC2.tab.tab.verboseRead", "= true, if info message that file is loading is to be printed [:#(type=Boolean)]",\
 39, true, 0.0,0.0,0.0,0,2610)
DeclareVariable("aC1DC2.tab.tab.columns[1]", "Columns of table to be interpolated [:#(type=Integer)]",\
 2, 0.0,0.0,0.0,0,2565)
DeclareVariable("aC1DC2.tab.tab.smoothness", "Smoothness of table interpolation [:#(type=Modelica.Blocks.Types.Smoothness)]",\
 1, 1.0,3.0,0.0,0,2565)
DeclareVariable("aC1DC2.tab.tab.tableID.id", "[:#(type=Integer)]", 0, 0.0,0.0,\
0.0,0,2565)
DeclareVariable("aC1DC2.tab.tab.tableOnFileRead", "= 1, if table was successfully read from file",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("aC1DC2.outputPower", "", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("aC1DC2.der(outputPower)", "", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("wiringAC1_1.terminal_n.v[1]", "Voltage vector [V]", \
"source1.terminal.v[1]", 1, 5, 5, 4)
DeclareAlias2("wiringAC1_1.terminal_n.v[2]", "Voltage vector [V]", \
"source1.terminal.v[2]", 1, 5, 6, 4)
DeclareAlias2("wiringAC1_1.terminal_n.i[1]", "Current vector [A]", \
"aC1DC2.terminal_n.i[1]", 1, 5, 24, 132)
DeclareAlias2("wiringAC1_1.terminal_n.i[2]", "Current vector [A]", \
"aC1DC2.terminal_n.i[2]", 1, 5, 25, 132)
DeclareAlias2("wiringAC1_1.terminal_n.theta[1]", "Optional vector of phase angles [rad|deg]",\
 "source1.terminal.theta[1]", 1, 5, 7, 4)
DeclareAlias2("wiringAC1_1.terminal_p.v[1]", "Voltage vector [V]", \
"source1.terminal.v[1]", 1, 5, 5, 4)
DeclareAlias2("wiringAC1_1.terminal_p.v[2]", "Voltage vector [V]", \
"source1.terminal.v[2]", 1, 5, 6, 4)
DeclareAlias2("wiringAC1_1.terminal_p.i[1]", "Current vector [A]", \
"aC1DC2.terminal_n.i[1]", -1, 5, 24, 132)
DeclareAlias2("wiringAC1_1.terminal_p.i[2]", "Current vector [A]", \
"aC1DC2.terminal_n.i[2]", -1, 5, 25, 132)
DeclareAlias2("wiringAC1_1.terminal_p.theta[1]", "Optional vector of phase angles [rad|deg]",\
 "source1.terminal.theta[1]", 1, 5, 7, 4)
DeclareVariable("wiringAC1_1.lossPower", "Power lost [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("wiringAC1_1.wiringLossPower", "Power lost [W]", "wiringAC1_1.lossPower", 1,\
 5, 141, 0)
DeclareParameter("wiringAC1_1.R", "wire resistance [Ohm]", 40, 0.02665, 0.0,0.0,\
0.0,0,560)
DeclareParameter("wiringAC1_1.shortOut", "if true, resistance is zero [:#(type=Boolean)]",\
 41, false, 0.0,0.0,0.0,0,562)
DeclareVariable("wiringAC1_1.Preal_p", "Real power transmitted at pin p [W]", \
0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("wiringAC1_1.Preal_n", "Real power transmitted at pin n [W]", \
0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("dataTable1.nout", "Number of outputs [:#(type=Integer)]", 13, \
1.0,1E+100,0.0,0,517)
DeclareVariable("dataTable1.y[1]", "Connector of Real output signals", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("dataTable1.y[2]", "Connector of Real output signals", 0.0, \
0.0,0.0,0.0,0,512)
DeclareAlias2("dataTable1.y[3]", "Connector of Real output signals [W]", \
"load1.P", 1, 5, 16, 0)
DeclareVariable("dataTable1.y[4]", "Connector of Real output signals", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("dataTable1.y[5]", "Connector of Real output signals", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("dataTable1.y[6]", "Connector of Real output signals", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("dataTable1.y[7]", "Connector of Real output signals", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("dataTable1.y[8]", "Connector of Real output signals", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("dataTable1.y[9]", "Connector of Real output signals", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("dataTable1.y[10]", "Connector of Real output signals", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("dataTable1.y[11]", "Connector of Real output signals", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("dataTable1.y[12]", "Connector of Real output signals", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("dataTable1.y[13]", "Connector of Real output signals", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("dataTable1.tableOnFile", "= true, if table is defined on file or in function usertab [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareParameter("dataTable1.verboseRead", "= true, if info message that file is loading is to be printed [:#(type=Boolean)]",\
 42, true, 0.0,0.0,0.0,0,562)
DeclareParameter("dataTable1.columns[1]", "Columns of table to be interpolated [:#(type=Integer)]",\
 43, 1, 0.0,0.0,0.0,0,564)
DeclareParameter("dataTable1.columns[2]", "Columns of table to be interpolated [:#(type=Integer)]",\
 44, 2, 0.0,0.0,0.0,0,564)
DeclareParameter("dataTable1.columns[3]", "Columns of table to be interpolated [:#(type=Integer)]",\
 45, 3, 0.0,0.0,0.0,0,564)
DeclareParameter("dataTable1.columns[4]", "Columns of table to be interpolated [:#(type=Integer)]",\
 46, 4, 0.0,0.0,0.0,0,564)
DeclareParameter("dataTable1.columns[5]", "Columns of table to be interpolated [:#(type=Integer)]",\
 47, 5, 0.0,0.0,0.0,0,564)
DeclareParameter("dataTable1.columns[6]", "Columns of table to be interpolated [:#(type=Integer)]",\
 48, 6, 0.0,0.0,0.0,0,564)
DeclareParameter("dataTable1.columns[7]", "Columns of table to be interpolated [:#(type=Integer)]",\
 49, 7, 0.0,0.0,0.0,0,564)
DeclareParameter("dataTable1.columns[8]", "Columns of table to be interpolated [:#(type=Integer)]",\
 50, 8, 0.0,0.0,0.0,0,564)
DeclareParameter("dataTable1.columns[9]", "Columns of table to be interpolated [:#(type=Integer)]",\
 51, 9, 0.0,0.0,0.0,0,564)
DeclareParameter("dataTable1.columns[10]", "Columns of table to be interpolated [:#(type=Integer)]",\
 52, 10, 0.0,0.0,0.0,0,564)
DeclareParameter("dataTable1.columns[11]", "Columns of table to be interpolated [:#(type=Integer)]",\
 53, 11, 0.0,0.0,0.0,0,564)
DeclareParameter("dataTable1.columns[12]", "Columns of table to be interpolated [:#(type=Integer)]",\
 54, 12, 0.0,0.0,0.0,0,564)
DeclareParameter("dataTable1.columns[13]", "Columns of table to be interpolated [:#(type=Integer)]",\
 55, 13, 0.0,0.0,0.0,0,564)
DeclareVariable("dataTable1.smoothness", "Smoothness of table interpolation [:#(type=Modelica.Blocks.Types.Smoothness)]",\
 2, 1.0,3.0,0.0,0,517)
DeclareParameter("dataTable1.extrapolation", "Extrapolation of data outside the definition range [:#(type=Modelica.Blocks.Types.Extrapolation)]",\
 56, 1, 1.0,4.0,0.0,0,564)
DeclareParameter("dataTable1.offset[1]", "Offsets of output signals", 57, 0, \
0.0,0.0,0.0,0,560)
DeclareVariable("dataTable1.startTime", "Output = offset for time < startTime [s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("dataTable1.t_min", "Minimum abscissa value defined in table [s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("dataTable1.t_max", "Maximum abscissa value defined in table [s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("dataTable1.p_offset[1]", "Offsets of output signals", 0.0, \
0.0,0.0,0.0,0,2561)
DeclareVariable("dataTable1.p_offset[2]", "Offsets of output signals", 0.0, \
0.0,0.0,0.0,0,2561)
DeclareVariable("dataTable1.p_offset[3]", "Offsets of output signals", 0.0, \
0.0,0.0,0.0,0,2561)
DeclareVariable("dataTable1.p_offset[4]", "Offsets of output signals", 0.0, \
0.0,0.0,0.0,0,2561)
DeclareVariable("dataTable1.p_offset[5]", "Offsets of output signals", 0.0, \
0.0,0.0,0.0,0,2561)
DeclareVariable("dataTable1.p_offset[6]", "Offsets of output signals", 0.0, \
0.0,0.0,0.0,0,2561)
DeclareVariable("dataTable1.p_offset[7]", "Offsets of output signals", 0.0, \
0.0,0.0,0.0,0,2561)
DeclareVariable("dataTable1.p_offset[8]", "Offsets of output signals", 0.0, \
0.0,0.0,0.0,0,2561)
DeclareVariable("dataTable1.p_offset[9]", "Offsets of output signals", 0.0, \
0.0,0.0,0.0,0,2561)
DeclareVariable("dataTable1.p_offset[10]", "Offsets of output signals", 0.0, \
0.0,0.0,0.0,0,2561)
DeclareVariable("dataTable1.p_offset[11]", "Offsets of output signals", 0.0, \
0.0,0.0,0.0,0,2561)
DeclareVariable("dataTable1.p_offset[12]", "Offsets of output signals", 0.0, \
0.0,0.0,0.0,0,2561)
DeclareVariable("dataTable1.p_offset[13]", "Offsets of output signals", 0.0, \
0.0,0.0,0.0,0,2561)
DeclareVariable("dataTable1.tableID.id", "[:#(type=Integer)]", 0, 0.0,0.0,0.0,0,2565)
DeclareVariable("dataTable1.nextTimeEvent", "Next time event instant [s]", 0, \
0.0,0.0,0.0,0,2704)
DeclareVariable("dataTable1.tableOnFileRead", "= 1, if table was successfully read from file",\
 0.0, 0.0,0.0,0.0,0,2561)
EndNonAlias(0)

#define DymolaHaveUpdateInitVars 1
#include <dsblock5.c>

DYMOLA_STATIC void UpdateInitVars(double*time, double* X_, double* XD_, double* U_, double* DP_, int IP_[], Dymola_bool LP_[], double* F_, double* Y_, double* W_, double QZ_[], double duser_[], int iuser_[], void*cuser_[],struct DYNInstanceData*did_) {
static Real initStore[1];
}
StartDataBlock
StartPreBlock
pre(DYNX(W_,176),"dataTable1.nextTimeEvent", 0, 0);
EndPreBlock
StartEqBlock
DoRemember_(DYNX(W_,24), 0, 0);
DoRemember_(DYNX(W_,25), 0, 1);
DoRemember_(DYNX(W_,26), 0.0, 3);
DoRemember_(DYNX(W_,27), 0.0, 2);
EndEqBlock
UpdateQEvaluate(1)
EndDataBlock

BreakSectionFunctionStart(0);
BreakSectionFunctionCallNew(1);
BreakSectionFunctionEnd()
